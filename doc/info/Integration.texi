@menu
* Introduction to Integration::
* Functions and Variables for Integration::
* Introduction to QUADPACK::
* Functions and Variables for QUADPACK::
@end menu

@c -----------------------------------------------------------------------------
@node Introduction to Integration, Functions and Variables for Integration, Integration, Integration
@section Introduction to Integration
@c -----------------------------------------------------------------------------

Maximaは積分を扱うためのいくつかのルーチンを持っています。
@mref{integrate}関数はそれらのほとんどを利用します。
指定されていない関数（ともちろんその導関数）を扱う @mref{antid}パッケージもあります。
数値目的のためには
@mref{quad_qag}, @mref{quad_qags}などと名付けられた
QUADPACKから適応積分器一式があります。
それらは見出し @code{QUADPACK}の下で記述されています。
超幾何関数を扱うことができます。詳細は @mref{specint}を参照してください。
一般的に言って、Maximaは「初等関数」（有理関数、三角関数、対数、指数関数、根号など）と
２、３の拡張（誤差関数、二重対数関数）を使った積分可能な積分だけを扱います。
@code{g(x)}や @code{h(x)}といった未知の関数を使った積分は扱いません。

@c end concepts Integration

@c -----------------------------------------------------------------------------
@node Functions and Variables for Integration, Introduction to QUADPACK, Introduction to Integration, Integration
@section Functions and Variables for Integration
@c -----------------------------------------------------------------------------

@c NEEDS WORK

@c -----------------------------------------------------------------------------
@anchor{changevar}
@deffn {関数} changevar (@var{expr}, @var{f(x,y)}, @var{y}, @var{x})

@var{x}に関する積分を含む @var{expr}の中に現れるすべての積分に関して、
@code{@var{f(x,y)} = 0}で与えられる変数変換を生成します。
新しい変数は @var{y}です。

変数の変更は@code{@var{f(x)} = @var{g(y)}}とも書けます。

@c HMM, THIS EXAMPLE YIELDS A CORRECT BUT SLIGHTLY STRANGE RESULT...
@example
(%i1) assume(a > 0)$
@group
(%i2) 'integrate (%e**sqrt(a*y), y, 0, 4);
                      4
                     /
                     [    sqrt(a) sqrt(y)
(%o2)                I  %e                dy
                     ]
                     /
                      0
@end group
@group
(%i3) changevar (%, y-z^2/a, z, y);
                      0
                     /
                     [                abs(z)
                   2 I            z %e       dz
                     ]
                     /
                      - 2 sqrt(a)
(%o3)            - ----------------------------
                                a
@end group
@end example

上の @code{'integrate}の例のような名詞形を含む式は
@code{nouns}フラグを使って @code{ev}で評価できます。
例えば、上の　@code{changevar}が返す式は
@code{ev (%o3, nouns)}で評価できます。

@code{changevar}は和や積のインデックスに関する変更にも使えます。
しかし、
変更が和や積の中でなされる時
この変更はシフトすなわち @code{i = j+ ...}
でなければならず、高階関数ではないことをはっきり理解しなければいけません。
例えば、

@example
@group
(%i4) sum (a[i]*x^(i-2), i, 0, inf);
                         inf
                         ====
                         \         i - 2
(%o4)                     >    a  x
                         /      i
                         ====
                         i = 0
@end group
@group
(%i5) changevar (%, i-2-n, n, i);
                        inf
                        ====
                        \               n
(%o5)                    >      a      x
                        /        n + 2
                        ====
                        n = - 2
@end group
@end example

@opencatbox
@category{Integral calculus}
@closecatbox
@end deffn

@c THIS ITEM IS A MESS, BUT DON'T BOTHER TO CLEAN IT UP:
@c THE GAUSS-KRONROD FUNCTIONS (QUADPACK) MAKE THIS OBSOLETE

@c -----------------------------------------------------------------------------
@deffn {関数} dblint (@var{f}, @var{r}, @var{s}, @var{a}, @var{b})

二重積分ルーチン。トップレベル Maximaで書かれ、翻訳され機械語にコンパイルされました。
このパッケージをアクセスするには @code{load ("dblint")}を使ってください。
以下を計算するため xとy方向に関してシンプソンの規則方法を使います。

@tex
$$\int_a^b \int_{r\left(x\right)}^{s\left(x\right)} f\left(x,y\right) \, dy \, dx.$$
@end tex
@ifnottex
@example
@group
/b /s(x)
|  |
|  |    f(x,y) dy dx
|  |
/a /r(x)
@end group
@end example
@end ifnottex

関数 @var{f}は翻訳かコンパイルされた2変数関数でなければいけなく、
@var{r}と @var{s}はそれぞれ、翻訳かコンパイルされた1変数関数でなければいけません。
一方で @var{a}と @var{b}は浮動小数点数でなければいけません。
ルーチンは xと yの区間の分割の数を決める２つのグローバル変数を持ちます:
@code{dblint_x}と @code{dblint_y}。
両方とも初期は10で、他の整数値に独立に変えることができます。
（x方向に計算される @code{2*dblint_x+1}点があり、
y方向に計算される @code{2*dblint_y+1}点があります）
ルーチンはX軸を更に分割します。
Xのそれぞれの値に関して、最初、
@code{@var{r}(x)}と @code{@var{s}(x)}を計算します;
そして @code{@var{r}(x)}と @code{@var{s}(x)}の間でY軸が更に分割され、
シンプソン規則を使ってY軸に沿っての積分が実行されます;
そして、
シンプソン規則を使って Y積分である関数値を用いて X軸に沿っての積分が実行されます;
この手続きは様々な理由のため数値的に不安定かもしれませんが、
かなり速いです:
非常に振動的な関数や特異点（領域内の極や分岐点）を持つ関数にこれを使うことは避けてください。
Y積分は @code{@var{r}(x)}と @code{@var{s}(x)}がどこくらい離れているかに依存します。
だからもし距離 @code{@var{s}(x) - @var{r}(x)}が Xに関して急速に変化するなら、
様々な Y積分で異なるステップサイズでの切り詰めから起こる本質的なエラーがあるかもしれません。
領域の範囲を改善するために @code{dblint_x}と @code{dblint_y}を増やすことができますが、
計算時間という犠牲を払うことになります。
関数値を保存しないので、関数が非常に時間がかかるものの場合、
もし何か変えたら再計算を待たなければいけません（すいません）。
関数 @var{f}, @var{r}, @var{s}は
@code{dblint}コールの前に翻訳かコンパイルされるかどちらかが要求されます。
これは多くの場合、インタープリタコードに対して桁違いの速度改善がなされるでしょう！

@code{demo ("dblint")}は
実例問題に適用された @code{dblint}のデモンストレーションを実行します。
@c demo (dblint_1) FAILS WITH Could not find `fltdfnk.mc' -- DON'T BOTHER TO MENTION IT. !!!
@c @code{demo (dblint_1)} executes another demonstration.

@opencatbox
@category{Integral calculus}
@closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@anchor{defint}
@deffn {関数} defint (@var{expr}, @var{x}, @var{a}, @var{b})

定積分を計算しようとします。
@code{integrate}は、
積分の範囲が指定された時、
すなわち @code{integrate}が
@code{integrate (@var{expr}, @var{x}, @var{a}, @var{b})}としてコールされた時、
@code{defint}をコールします。

このようにユーザーの観点からは @code{integrate}をコールすれば十分です。
@c SHOULD WE BOTHER TO DOCUMENT defint ??? NO FUNCTIONALITY HERE THAT IS NOT ALREADY PRESENT IN integrate !!!

@code{defint}はシンボリック式、計算された積分または積分の名詞形を返します。
定積分の数値近似に関しては @mref{quad_qag}と関連関数を参照してください。

@opencatbox
@category{Integral calculus}
@closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@anchor{erfflag}
@defvr {オプション変数} erfflag
デフォルト値: @code{true}

@code{erfflag}が @code{false}の時、
もし始めから被積分に何もないなら
(if there were none in the integrad to begin with)
@code{risch}が答えの中に @code{erf}関数を導入することを抑制します。

@opencatbox
@category{Integral calculus}
@closecatbox
@end defvr

@c NEEDS WORK

@c -----------------------------------------------------------------------------
@anchor{ilt}
@deffn {関数} ilt (@var{expr}, @var{s}, @var{t})

@var{expr}の @var{s}とパラメータ @var{t}に関する逆ラプラス変換を計算します。
@var{expr}は分子が線形２次因子だけを持つ多項式の比でなければいけません。
@code{solve}か @code{linsolve}と合わせて
関数 @code{laplace}や @code{ilt}を使うことによって
ユーザーは微分方程式または畳み込み積分方程式やそれらの組を解くことができます。

@example
@group
(%i1) 'integrate (sinh(a*x)*f(t-x), x, 0, t) + b*f(t) = t**2;
              t
             /
             [                                    2
(%o1)        I  f(t - x) sinh(a x) dx + b f(t) = t
             ]
             /
              0
@end group
@group
(%i2) laplace (%, t, s);
                               a laplace(f(t), t, s)   2
(%o2)  b laplace(f(t), t, s) + --------------------- = --
                                       2    2           3
                                      s  - a           s
@end group
@group
(%i3) linsolve ([%], ['laplace(f(t), t, s)]);
                                        2      2
                                     2 s  - 2 a
(%o3)     [laplace(f(t), t, s) = --------------------]
                                    5         2     3
                                 b s  + (a - a  b) s
@end group
@group
(%i4) ilt (rhs (first (%)), s, t);
Is  a b (a b - 1)  positive, negative, or zero?

pos;
               sqrt(a b (a b - 1)) t
        2 cosh(---------------------)       2
                         b               a t
(%o4) - ----------------------------- + -------
              3  2      2               a b - 1
             a  b  - 2 a  b + a

                                                       2
                                             + ------------------
                                                3  2      2
                                               a  b  - 2 a  b + a
@end group
@end example

@opencatbox
@category{Laplace transform}
@closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@anchor{intanalysis}
@defvr {オプション変数} intanalysis
デフォルト値: @code{true}

@code{true}の時、定積分が積分区間内の被積分関数の極を見つけようとします。
もしあるなら、積分は主値積分として適切に評価されます。
もしintanalysisが @code{false}なら、
このチェックは実行されず積分は極がないことを仮定して実行されます。

@mref{ldefint}も参照してください。

例:

@mref{intanalysis}が @code{false}に設定されている時
Maximaは以下の積分を解くことができます:

@c ===beg===
@c integrate(1/(sqrt(x+1)+1),x,0,1);
@c integrate(1/(sqrt(x)+1),x,0,1),intanalysis:false;
@c integrate(cos(a)/sqrt((tan(a))^2+1),a,-%pi/2,%pi/2);
@c intanalysis:false$
@c integrate(cos(a)/sqrt((tan(a))^2 +1),a,-%pi/2,%pi/2);
@c ===end===
@example
(%i1) integrate(1/(sqrt(x)+1),x,0,1);
                                1
                               /
                               [       1
(%o1)                          I  ----------- dx
                               ]  sqrt(x) + 1
                               /
                                0

(%i2) integrate(1/(sqrt(x)+1),x,0,1),intanalysis:false;
(%o2)                            2 - 2 log(2)

(%i3) integrate(cos(a)/sqrt((tan(a))^2 +1),a,-%pi/2,%pi/2);
The number 1 isn't in the domain of atanh
 -- an error. To debug this try: debugmode(true);

(%i4) intanalysis:false$
(%i5) integrate(cos(a)/sqrt((tan(a))^2+1),a,-%pi/2,%pi/2);
                                      %pi
(%o5)                                 ---
                                       2
@end example

@opencatbox
@category{Integral calculus}
@closecatbox
@end defvr

@anchor{integrate}
@deffn  {関数} integrate @
@fname{integrate} (@var{expr}, @var{x}) @
@fname{integrate} (@var{expr}, @var{x}, @var{a}, @var{b})

@var{x}に関する @var{expr}の積分をシンボリックに計算しようとします。
@code{integrate (@var{expr}, @var{x})}は不定積分で、
@code{integrate (@var{expr}, @var{x}, @var{a}, @var{b})}は
@var{a},@var{b}の上限下限を持つ定積分です。
上限下限は @var{x}を含んではいけません。
しかし @code{integrate}はこの制限を強制するわけではありません。
@var{a}は @var{b}より小さい必要はありません。
@var{b}が @var{a}と等しいなら @code{integrate}は0を返します。

定積分の数値近似に関しては @mref{quad_qag}と関連関数を参照してください。
（複素積分）留数の計算に関しては @mref{residue}を参照してください。
不定積分の代替計算方法に関しては @mref{antid}を参照してください。

@code{integrate}が成功したら積分（@code{integrate}を含まない式）を返します。
そうでないなら、積分の名詞形式（クォートされた演算子
@code{'integrate})もしくは１つ以上の名詞形式を含む式を返します。
@code{integrate}の名詞形式は積分記号で表示されます。

いくつかの環境では、例えば @code{'integrate (@var{expr}, @var{x})}のような
シングルクオートされた@code{integrate}で手動で名詞形式を構成することが役に立ちます。
例えば、積分はまだ計算されていないいくつかのパラメータに依存しているかもしれません。
@code{ev (@var{i}, nouns)}を使って積分の名詞をその引数に利用することができます。
ここで @var{i}は問題の名詞形式です。

@c BEGIN EXPOSITION ON HEURISTICS
@code{integrate}は不定積分とは別に定積分を扱います。
それぞれの場合を扱うため ある範囲の発見法を用意しています。
定積分の特別な場合は 0や無限大 (@mref{inf}か @mref{minf})に等しい積分の下限上限を含んだり、
0や@code{%pi}や@code{2 %pi}に等しい下限上限を持つ三角関数を含んだり、
有理関数や @mref{beta}や @mref{psi}関数の定義に関連した積分やいくつかの対数的な積分、三角関数積分を含んだりします。
有理関数の処理は留数の計算を含むかもしれません。
もし適用可能な特殊な場合が見つからないなら
不定積分を計算し下限上限でそれを評価しようとするでしょう。
これは下限上限に無限大の極限を取ることを含みます。
@mref{ldefint}も参照してください。

不定積分の特殊な場合は三角関数、指数対数関数、有理関数を含みます。
@code{integrate}は初等積分の短いテーブルもまた利用しています。

もし非積分関数が形式 @code{f(g(x)) * diff(g(x), x)}を持つなら
@code{integrate}は変数の交換を実行します。
@code{integrate}は @code{g(x)}の導関数が非積分関数を割るような部分式
@code{g(x)}を見つけようとします。
この探索は @code{gradef}関数が定義した導関数を利用します。
@mref{changevar}や @mref{antid}も参照ください。

もしこれまでの発見法のどれも不定積分を見つけられないなら
リッシュのアルゴリズムを実行します。
フラグ @mref{risch}が
@code{ev}のコールやコマンドライン上で @mref{evflag}として設定されるかもしれません。
例えば @code{ev (integrate (@var{expr}, @var{x}), risch)}や
@code{integrate (@var{expr}, @var{x}), risch}というようにです。
もし @code{risch}が @code{true}なら
@code{integrate}は発見法を最初に試さずに @mref{risch}関数をコールします。
@mref{risch}も参照ください。
@c END EXPOSITION ON HEURISTICS

@code{integrate}は @code{f(x)}記法で明示的に表現された関数関係に対してだけ機能します。
@code{integrate}は @mref{depends}関数が規定した陰の依存性を考慮しません。

@code{integrate}は非積分関数のパラメータのある性質を知っている必要がある場合があります。
@code{integrate}は @code{assume}データベースを最初に参照し、
注目の変数がそこにないなら @code{integrate}はユーザーに問い合わせます。
質問に依存して、適切な応答は @code{yes;}や@code{no;}, @code{pos;}, @code{zero;},
@code{neg;}などです。

@code{integrate}は線形には宣言されていません。
@code{declare}と @code{linear}を参照ください。

@code{integrate}は２、３の特集な場合だけ、部分積分を企てます。

例:

@itemize @bullet
@item
初等不定積分、定積分

@example
@group
(%i1) integrate (sin(x)^3, x);
                           3
                        cos (x)
(%o1)                   ------- - cos(x)
                           3
@end group
@group
(%i2) integrate (x/ sqrt (b^2 - x^2), x);
                                 2    2
(%o2)                    - sqrt(b  - x )
@end group
@group
(%i3) integrate (cos(x)^2 * exp(x), x, 0, %pi);
                               %pi
                           3 %e      3
(%o3)                      ------- - -
                              5      5
@end group
@group
(%i4) integrate (x^2 * exp(-x^2), x, minf, inf);
                            sqrt(%pi)
(%o4)                       ---------
                                2
@end group
@end example

@item
@code{assume}と対話的問い合わせの利用

@example
(%i1) assume (a > 1)$
@group
(%i2) integrate (x**a/(x+1)**(5/2), x, 0, inf);
    2 a + 2
Is  -------  an integer?
       5

no;
Is  2 a - 3  positive, negative, or zero?

neg;
                                   3
(%o2)                  beta(a + 1, - - a)
                                   2
@end group
@end example

@item
変数変換。この例では２回変数変換があります:
@mref{gradef}が規定した導関数を使ったものと未知関数
@code{r(x)}の微分 @code{diff(r(x))}を使ったもの。

@example
@group
(%i3) gradef (q(x), sin(x**2));
(%o3)                         q(x)
@end group
@group
(%i4) diff (log (q (r (x))), x);
                      d               2
                     (-- (r(x))) sin(r (x))
                      dx
(%o4)                ----------------------
                            q(r(x))
@end group
@group
(%i5) integrate (%, x);
(%o5)                     log(q(r(x)))
@end group
@end example

@item
@code{'integrate}名詞形を含む戻り値。
この例では Maximaは有理関数の分母の因子1つを抽出できますが、
残りを因数分解できず、いずれにせよ積分を見つけられません。
@mref{grind}は結果の中に名詞形 @code{'integrate}を出力します。
積分や有理関数について更に知るには @mref{integrate_use_rootsof}も参照ください。

@example
@group
(%i1) expand ((x-4) * (x^3+2*x+1));
                    4      3      2
(%o1)              x  - 4 x  + 2 x  - 7 x - 4
@end group
@group
(%i2) integrate (1/%, x);
                              /  2
                              [ x  + 4 x + 18
                              I ------------- dx
                              ]  3
                 log(x - 4)   / x  + 2 x + 1
(%o2)            ---------- - ------------------
                     73               73
@end group
@group
(%i3) grind (%);
log(x-4)/73-('integrate((x^2+4*x+18)/(x^3+2*x+1),x))/73$
@end group
@end example

@item
積分を使った関数の定義。
関数の本体は関数を定義する時には評価されません。
この例では @code{f_1}の本体が @code{integrate}の名詞形を含みます。
クォートクォート演算子@code{'@w{}'}があると積分が評価され、その結果が
@code{f_2}の本体になります。

@example
@group
(%i1) f_1 (a) := integrate (x^3, x, 1, a);
                                     3
(%o1)           f_1(a) := integrate(x , x, 1, a)
@end group
@group
(%i2) ev (f_1 (7), nouns);
(%o2)                          600
@end group
@group
(%i3) /* Note parentheses around integrate(...) here */
      f_2 (a) := ''(integrate (x^3, x, 1, a));
                                   4
                                  a    1
(%o3)                   f_2(a) := -- - -
                                  4    4
@end group
@group
(%i4) f_2 (7);
(%o4)                          600
@end group
@end example
@end itemize

@opencatbox
@category{Integral calculus}
@closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@anchor{integration_constant}
@defvr {システム変数} integration_constant
デフォルト値: @code{%c}

等式の不定積分が積分定数を導入し、
@code{integration_constant}と
@code{integration_constant_counter}を連結することで定数名を構成します。

@code{integration_constant}には任意のシンボルに割り当てられます。

例:

@c ===beg===
@c integrate (x^2 = 1, x);
@c integration_constant : 'k;
@c integrate (x^2 = 1, x);
@c ===end===
@example
@group
(%i1) integrate (x^2 = 1, x);
                           3
                          x
(%o1)                     -- = x + %c1
                          3
@end group
@group
(%i2) integration_constant : 'k;
(%o2)                           k
@end group
@group
(%i3) integrate (x^2 = 1, x);
                            3
                           x
(%o3)                      -- = x + k2
                           3
@end group
@end example

@opencatbox
@category{Integral calculus}
@closecatbox
@end defvr

@c -----------------------------------------------------------------------------
@anchor{integration_constant_counter}
@defvr {システム変数} integration_constant_counter
デフォルト値: 0

等式の不定積分が積分定数を導入する時、
@code{integration_constant}と
@code{integration_constant_counter}を連結することで定数を構成します。

@code{integration_constant_counter}は次の積分定数を構成する前に増分されます。

例:

@c ===beg===
@c integrate (x^2 = 1, x);
@c integrate (x^2 = 1, x);
@c integrate (x^2 = 1, x);
@c reset (integration_constant_counter);
@c integrate (x^2 = 1, x);
@c ===end===
@example
@group
(%i1) integrate (x^2 = 1, x);
                           3
                          x
(%o1)                     -- = x + %c1
                          3
@end group
@group
(%i2) integrate (x^2 = 1, x);
                           3
                          x
(%o2)                     -- = x + %c2
                          3
@end group
@group
(%i3) integrate (x^2 = 1, x);
                           3
                          x
(%o3)                     -- = x + %c3
                          3
@end group
@group
(%i4) reset (integration_constant_counter);
(%o4)            [integration_constant_counter]
@end group
@group
(%i5) integrate (x^2 = 1, x);
                           3
                          x
(%o5)                     -- = x + %c1
                          3
@end group
@end example

@opencatbox
@category{Integral calculus}
@closecatbox

@end defvr

@c -----------------------------------------------------------------------------
@anchor{integrate_use_rootsof}
@defvr {オプション変数} integrate_use_rootsof
デフォルト値: @code{false}

@code{integrate_use_rootsof}が @code{true}でかつ有理関数の分子が因数分解できない時、
@mref{integrate}は分子の（まだ知られていない）根上の和という形式で積分を返します。

例えば
@code{integrate_use_rootsof}を @code{false}に設定すると、
@code{integrate}は有理関数の未解決積分を名詞形で返します:

@example
(%i1) integrate_use_rootsof: false$
@group
(%i2) integrate (1/(1+x+x^5), x);
        /  2
        [ x  - 4 x + 5
        I ------------ dx                            2 x + 1
        ]  3    2                2            5 atan(-------)
        / x  - x  + 1       log(x  + x + 1)          sqrt(3)
(%o2)   ----------------- - --------------- + ---------------
                7                 14             7 sqrt(3)
@end group
@end example

さあ、フラグを @code{true}に設定し、
積分の未解決部分を有理関数の分子の根上の和として表現しましょう:

@example
(%i3) integrate_use_rootsof: true$
@group
(%i4) integrate (1/(1+x+x^5), x);
      ====        2
      \       (%r4  - 4 %r4 + 5) log(x - %r4)
       >      -------------------------------
      /                    2
      ====            3 %r4  - 2 %r4
                        3      2
      %r4 in rootsof(%r4  - %r4  + 1, %r4)
(%o4) ----------------------------------------------------------
               7

                                                      2 x + 1
                                  2            5 atan(-------)
                             log(x  + x + 1)          sqrt(3)
                           - --------------- + ---------------
                                   14             7 sqrt(3)
@end group
@end example

代わりにユーザーは別々に分子の根を計算できます。
例えば、もし分子が3次多項式なら
@code{1/((x - a)*(x - b)*(x - c))}とか
@code{1/((x^2 - (a+b)*x + a*b)*(x - c))}というように
これらの根を使って被積分関数を表現できます。
これは時々 Maximaがもっと役立つ結果を得るのを助けます。

@opencatbox
@category{Integral calculus}
@closecatbox

@end defvr

@c NEEDS EXAMPLES

@c -----------------------------------------------------------------------------
@anchor{ldefint}
@deffn {関数} ldefint (@var{expr}, @var{x}, @var{a}, @var{b})

@var{expr}の @var{x}に関する不定積分を上限 @var{b}と下限 @var{a}で評価するために、
@mref{limit}を使って @var{expr}の定積分を計算しようとします。
もし定積分を計算するのに失敗したなら、
@code{ldefint}は名詞形として極限を含む式を返します。

@code{ldefint}は @mref{integrate}からコールされません。
なので、
@code{ldefint (@var{expr}, @var{x}, @var{a}, @var{b})}
を実行することは
@code{integrate (@var{expr}, @var{x}, @var{a}, @var{b})}
とは違った結果をもたらすかもしれません。
@code{ldefint}は定積分を評価するためにいつも同じ方法を使いますが、
@code{integrate}は様々な発見的方法を利用し、いくつかの特殊な場合を認識することもあります。

@opencatbox
@category{Integral calculus}
@closecatbox
@end deffn

@c UMM, IS THERE SOME TEXT MISSING HERE ???
@c WHAT IS THIS ABOUT EXACTLY ??

@c -----------------------------------------------------------------------------
@anchor{potential}
@deffn {関数} potential (@var{givengradient})

計算にはグローバル変数@code{potentialzeroloc[0]}を利用します。
それは @code{nonlist}か形式
@example
[indeterminatej=expressionj, indeterminatek=expressionk, ...]
@end example
でなければいけません。
ここで前者 (@code{nonlist})は後者(リスト形式)の中の右辺すべてに関して
nonlist式とすることと同値です。
示された右辺は積分の下限として使われます。
積分が成功するかどうかはそれらの値と順序に依存するかもしれません。
@code{potentialzeroloc}は0に初期化されます。

@end deffn

@c -----------------------------------------------------------------------------
@anchor{residue}
@deffn {関数} residue (@var{expr}, @var{z}, @var{z_0})

変数 @var{z}が値 @var{z_0}を仮定する時、
式 @var{expr}の複素平面での留数を計算します。
留数は @var{expr}のローラン級数における
@code{(@var{z} - @var{z_0})^(-1)}の係数です。

@example
@group
(%i1) residue (s/(s**2+a**2), s, a*%i);
                                1
(%o1)                           -
                                2
@end group
@group
(%i2) residue (sin(a*x)/x**4, x, 0);
                                 3
                                a
(%o2)                         - --
                                6
@end group
@end example

@opencatbox
@category{Integral calculus} @category{Complex variables}
@closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@anchor{risch}
@deffn {関数} risch (@var{expr}, @var{x})

リッシュアルゴリズムの超越な場合を使って @var{expr}を @var{x}に関して積分します。
（リッシュアルゴリズムの代数的な場合は実装されていません。）
これは現在、
@code{integrate}の主要部が対応できない入れ子の指数関数や対数関数の場合を扱います。
@mref{integrate}は、これらの場合が与えられたなら自動的に @code{risch}を適用します。

@code{erfflag}を @code{false}にすると、
もしそもそも被積分関数になにもないなら、
@code{risch}が答えの中に @code{erf}関数を導入することを抑制します。

@example
@group
(%i1) risch (x^2*erf(x), x);
                                                        2
             3                      2                - x
        %pi x  erf(x) + (sqrt(%pi) x  + sqrt(%pi)) %e
(%o1)   -------------------------------------------------
                              3 %pi
@end group
@group
(%i2) diff(%, x), ratsimp;
                             2
(%o2)                       x  erf(x)
@end group
@end example

@opencatbox
@category{Integral calculus}
@closecatbox
@end deffn

@c NEEDS EXPANSION, CLARIFICATION, AND EXAMPLES

@c -----------------------------------------------------------------------------
@anchor{tldefint}
@deffn {関数} tldefint (@var{expr}, @var{x}, @var{a}, @var{b})

@code{tlimswitch}が @code{true}に設定されている @code{ldefint}と同値です。

@opencatbox
@category{Integral calculus}
@closecatbox
@end deffn

@footnotestyle end

@c -----------------------------------------------------------------------------
@node Introduction to QUADPACK, Functions and Variables for QUADPACK, Functions and Variables for Integration, Integration
@section Introduction to QUADPACK
@c -----------------------------------------------------------------------------

@c FOLLOWING TEXT ADAPTED WITH HEAVY MODIFICATION FROM http://www.netlib.org/slatec/src/qpdoc.f

QUADPACKは１次元定積分の数値計算のための関数のコレクションです。
R. Piessens @footnote{Applied Mathematics and Programming Division, K.U. Leuven},
E. de Doncker @footnote{Applied Mathematics and Programming Division, K.U. Leuven},
C. Ueberhuber @footnote{Institut f@"ur Mathematik, T.U. Wien},
D. Kahaner @footnote{National Bureau of Standards, Washington, D.C., U.S.A}.
の合同プロジェクトから始まりました。

Maximaに含まれる QUADPACKライブラリは、
SLATEC共通数学ライブラリ バージョン
4.1@footnote{@url{http://www.netlib.org/slatec}}に現れる
QUADPACKの Fortranのソースコードの(プログラム@code{f2cl}による)自動翻訳です。

SLATECライブラリは1993年7月付ですが、QUADPACK関数は何年か前に書かれました。
QUADPACKももう１つのバージョンが
Netlib @footnote{@url{http://www.netlib.org/quadpack}}にあります;
このバージョンが SLATECバージョンとどう違うのかはっきりしません。

Maximaに含まれる QUADPACK関数は、
これらの関数が不特定の回数の関数の評価を要求し、
指定された精度まで結果を計算しようとする意味で、
すべて自動です。
Maximaの QUADPACKの Lisp翻訳はいくつかの自動でない関数も含みますが、
それらは Maximaレベルで公開されていません。

QUADPACKについての更なる情報は QUADPACK本
@footnote{R. Piessens, E. de Doncker-Kapenga, C.W. Uberhuber, and D.K. Kahaner.
@i{QUADPACK: A Subroutine Package for Automatic Integration.}
Berlin: Springer-Verlag, 1983, ISBN 0387125531.}
の中に見つけることができます。

@c -----------------------------------------------------------------------------
@subsection Overview
@c -----------------------------------------------------------------------------

@table @code
@item @mref{quad_qag}
一般関数の有限の区間上の積分。
@mref{quad_qag}は
Aind(Piessens, 1973)の戦略を使った簡単な大域的適応積分器を実装しています。
呼び出し側はルール評価コンポーネントを
ガウスークロンロッドの求積公式の6つのペアの中から選ぶことができます。
強く振動する非積分関数には高次のルールが適切です。

@item @mref{quad_qags}
一般関数の有限の区間上の積分。
@mref{quad_qags}はイプシロンアルゴリズム(Wynn, 1956)による外挿
(de Doncker,1978)を使った大域的適応積分器を実装しています。

@item @mref{quad_qagi}
一般関数の無限のもしくは半無限の区間上の積分。
区間を有限の区間上に写像し、 @code{quad_qags}の中で使うのと同じ戦略を適用します。

@item @mref{quad_qawo}
@ifnottex
@math{cos(omega x) f(x)}
@end ifnottex
@tex
$\cos\left(\omega \, x\right) \, f\left(x\right)$
@end tex
や
@ifnottex
@math{sin(omega x) f(x)}
@end ifnottex
@tex
$\sin\left(\omega \, x\right) \, f\left(x\right)$
@end tex
の有限の区間上の積分。
ここで、
@ifnottex
@math{omega}
@end ifnottex
@tex
$\omega$
@end tex
は定数です。
規則評価構成要素は変形 Clenshaw-Curtis手法に基づいています。
@mref{quad_qawo}は @mref{quad_qags}に似て、外挿とともに適応再分割を適用します。

@item @mref{quad_qawf}
フーリエコサイン変換かフーリエサイン変換を半無限区間上で計算します。
@mref{quad_qawo}で使うのと同じアプローチを連続する区間に適用し、
イプシロンアルゴリズム(Wynn, 1956)を使った収束の促進を積分寄与の級数に適用します。

@item @mref{quad_qaws}
@ifnottex
@math{w(x) f(x)}
@end ifnottex
@tex
$w\left(x\right) \, f\left(x\right)$
@end tex
の有限区間
@ifnottex
@math{[a, b]}
@end ifnottex
@tex
$\left[a, b\right]$
@end tex
上の積分。
ここで、
@ifnottex
@math{w}
@end ifnottex
@tex
$w$
@end tex
は形式
@ifnottex
@math{(x - a)^alpha (b - x)^beta v(x)}
@end ifnottex
@tex
$\left(x - a\right)^\alpha \, \left(b - x\right)^\beta \, v\left(x\right)$
@end tex
の関数で、
@ifnottex
@math{v(x)}
@end ifnottex
@tex
$v\left(x\right)$
@end tex
は、
@ifnottex
1, @math{log(x - a)}, @math{log(b - x)}, @math{log(x - a) log(b - x)}
@end ifnottex
@tex
$1$, $\log\left(x - a\right)$
, $\log\left(b - x\right)$, $\log\left(x - a\right) \, \log\left(b - x\right)$
@end tex
のいずれかであり、
@ifnottex
@math{alpha > -1}
@end ifnottex
@tex
$\alpha > -1$
@end tex
かつ
@ifnottex
@math{beta > -1}
@end ifnottex
@tex
$\beta > -1$
@end tex
です。

大域的適応再分割戦略を適用し、
@math{a}か @math{b}を含む部分区間上では変形
Clenshaw-Curtis積分を使います。

@item @mref{quad_qawc}
@math{f(x)/(x - c)}のコーシーの主値を有限の区間
@math{(a, b)}上で指定された @math{c}を用いて計算します。
戦略は大域的適応的で、
点 @math{x = c}を含む部分範囲上で変形 Clenshaw-Curtis積分を使います。

@item @mref{quad_qagp}
基本的に @mref{quad_qags}と同様ですが、被積分関数の特異点や不連続点を
提供しなければいけません。
これは積分器がよい解を生成するのをより容易にします。
@end table


@opencatbox
@category{Integral calculus} @category{Numerical methods} @category{Share packages} @category{Package quadpack}
@closecatbox

@c -----------------------------------------------------------------------------
@node Functions and Variables for QUADPACK, , Introduction to QUADPACK, Integration
@section Functions and Variables for QUADPACK
@c -----------------------------------------------------------------------------

@c THERE ARE OPTIONAL ARGUMENTS WHICH MAKES LISTING THE VARIANTS A LITTLE TEDIOUS
@c NEED A MORE CONVENIENT (AND NONAMBIGUOUS) NOTATION FOR OPTIONAL ARGUMENTS

@c -----------------------------------------------------------------------------
@anchor{quad_qag}
@deffn  {関数} quad_qag @
@fname{quad_qag} (@var{f(x)}, @var{x}, @var{a}, @var{b}, @var{key}, [@var{epsrel}, @var{epsabs}, @var{limit}]) @
@fname{quad_qag} (@var{f}, @var{x}, @var{a}, @var{b}, @var{key}, [@var{epsrel}, @var{epsabs}, @var{limit}])

一般関数の有限の区間上の積分。
@code{quad_qag}は Aind(Piessens, 1973)の戦略を使った
簡単な大域的適応積分器を実装しています。
呼び出し側はルール評価コンポーネントを
ガウスークロンロッドの求積公式の6つのペアの中から選ぶことができます。
強く振動する非積分関数には高次のルールが適切です。

quad_qagは積分
@ifnottex
@math{integrate (f(x), x, a, b)}
@end ifnottex
@tex
$$\int_a^b {f(x) \, dx}$$
@end tex
を計算します。

非積分関数は依存変数 @var{x}の @var{f(x)}であり、
関数は下限 @var{a}上限 @var{b}の間で積分されます。
@var{key}は利用する積分器で、 1から 6までのいずれかの整数でなければなりません。
@var{key}の値はガウスークロンロッドの積分ルールの次数を選びます。
高次のルールが強く振動する非積分関数には適切です。

非積分関数は Maximaか Lisp関数か 演算子の名前であるか Maximaのラムダ式か一般的な
Maximaの式として指定することができます。

数値積分は、望まれる精度を達成するまで
積分領域を部分区間に分割することによって適応的に実行されます。

キーワード引数はオプションで、どの次数においても指定できます。
それらは形式 @code{key=val}を取ります。キーワード引数は：

@table @code
@item epsrel
望まれる近似の相対誤差。デフォルトは1d-8。
@item epsabs
望まれる近似の絶対誤差。デフォルトは0。
@item limit
内部の作業配列のサイズ。 limitは使用する部分区間の最大数。デフォルトは200。
@end table

@code{quad_qag}は４つの要素のリストを返します:

@itemize
@item
積分の近似
@item
見積もられた近似の絶対誤差
@item
非積分関数の評価数
@item
エラーコード
@end itemize

エラーコード（戻り値の４番目の要素）は以下の値を取ります:

@table @code
@item 0
問題が発生しなかった場合;
@item 1
部分区間の数が上限を超えた場合;
@item 2
丸め誤差が超過した場合;
@item 3
非積分関数の振る舞いが極端に悪い場合;
@item 6
入力が無効な場合;

@end table

@c NEED CROSS REFS HERE -- EITHER CROSS REF A QUADPACK OVERVIEW, OR CROSS REF EACH OF THE quad_* FUNCTIONS

例:

@example
@group
(%i1) quad_qag (x^(1/2)*log(1/x), x, 0, 1, 3, 'epsrel=5d-8);
(%o1)    [.4444444444492108, 3.1700968502883E-9, 961, 0]
@end group
@group
(%i2) integrate (x^(1/2)*log(1/x), x, 0, 1);
                                4
(%o2)                           -
                                9
@end group
@end example

@opencatbox
@category{Numerical methods} @category{Package quadpack}
@closecatbox
@end deffn

@c THERE ARE OPTIONAL ARGUMENTS WHICH MAKES LISTING THE VARIANTS A LITTLE TEDIOUS
@c NEED A MORE CONVENIENT (AND NONAMBIGUOUS) NOTATION FOR OPTIONAL ARGUMENTS

@c -----------------------------------------------------------------------------
@anchor{quad_qags}
@deffn  {関数} quad_qags @
@fname{quad_qags} (@var{f(x)}, @var{x}, @var{a}, @var{b}, [@var{epsrel}, @var{epsabs}, @var{limit}]) @
@fname{quad_qags} (@var{f}, @var{x}, @var{a}, @var{b}, [@var{epsrel}, @var{epsabs}, @var{limit}])

一般関数の有限の区間上の積分。
@code{quad_qags}はイプシロンアルゴリズム (Wynn, 1956)による外挿
(de Doncker,1978)を使った大域的適応積分器を実装しています。

@code{quad_qags}は、積分

@ifnottex
@math{integrate (f(x), x, a, b)}
@end ifnottex
@tex
$$\int_a^b {f(x) \, dx}$$
@end tex
を計算します。

非積分関数は従属変数 @var{x}の関数 @var{f(x)}であり、
関数は下限 @var{a}上限 @var{b}の間で積分されます。

非積分関数は、Maximaか Lisp関数か 演算子の名前であるか Maximaのラムダ式か一般的な
Maximaの式として指定することができます。

キーワード引数はオプションで、どの次数においても指定できます。
それらは形式 @code{key=val}を取ります。キーワード引数は：

@table @code
@item epsrel
望まれる近似の相対誤差。デフォルトは1d-8。
@item epsabs
望まれる近似の絶対誤差。デフォルトは0。
@item limit
内部の作業配列のサイズ。 limitは使用する部分区間の最大数。デフォルトは200。
@end table

@code{quad_qags}は４つの要素のリストを返します:

@itemize
@item
積分の近似
@item
見積もられた近似の絶対誤差
@item
非積分関数の評価数
@item
エラーコード
@end itemize

エラーコード（戻り値の４番目の要素）は以下の値を取ります:

@table @code
@item 0
問題が発生しなかった場合;
@item 1
部分区間の数が上限を超えた場合;
@item 2
丸め誤差が超過した場合;
@item 3
非積分関数の振る舞いが極端に悪い場合;
@item 4
収束に失敗した場合;
@item 5
積分が発散しているか収束が遅い場合;
@item 6
入力が無効な場合;
@end table

@c NEED CROSS REFS HERE -- EITHER CROSS REF A QUADPACK OVERVIEW, OR CROSS REF EACH OF THE quad_* FUNCTIONS

例:

@example
@group
(%i1) quad_qags (x^(1/2)*log(1/x), x, 0, 1, 'epsrel=1d-10);
(%o1)   [.4444444444444448, 1.11022302462516E-15, 315, 0]
@end group
@end example

この積分に関しては @code{quad_qags}は
@code{quad_qag}よりも精確で効率的であることに注意してください。

@opencatbox
@category{Numerical methods} @category{Package quadpack}
@closecatbox
@end deffn

@c THERE ARE OPTIONAL ARGUMENTS WHICH MAKES LISTING THE VARIANTS A LITTLE TEDIOUS
@c NEED A MORE CONVENIENT (AND NONAMBIGUOUS) NOTATION FOR OPTIONAL ARGUMENTS

@c -----------------------------------------------------------------------------
@anchor{quad_qagi}
@deffn  {関数} quad_qagi @
@fname{quad_qagi} (@var{f(x)}, @var{x}, @var{a}, @var{b}, [@var{epsrel}, @var{epsabs}, @var{limit}]) @
@fname{quad_qagi} (@var{f}, @var{x}, @var{a}, @var{b}, [@var{epsrel}, @var{epsabs}, @var{limit}])

一般関数の無限のもしくは半無限の区間上の積分。
区間を有限の区間上に写像し、 @code{quad_qags}の中で使うのと同じ戦略を適用します。

@code{quad_qagi}は Quadpack QAGIルーチンを使って以下の積分の１つを評価します。

@ifnottex
@math{integrate (f(x), x, a, inf)}
@end ifnottex
@tex
$$\int_a^\infty {f(x) \, dx}$$
@end tex

@ifnottex
@math{integrate (f(x), x, minf, a)}
@end ifnottex
@tex
$$\int_\infty^a {f(x) \, dx}$$
@end tex

@ifnottex
@math{integrate (f(x), x, minf, inf)}
@end ifnottex
@tex
$$\int_{-\infty}^\infty {f(x) \, dx}$$
@end tex

被積分関数は従属変数 @var{x}の関数 @var{f(x)}であり、無限範囲上で積分されます。

被積分関数は Maximaか Lispの関数か演算子の名前であるか、
Maximaのラムダ式か Maximaの一般式として指定することができます。

積分の境界の１つは無限でなければいけません。
もしそうでないなら @code{quad_qagi}はただ名詞形を返します。

キーワード引数は随意で、任意の順序で指定できます。
それらすべては形式 @code{key=val}を取ります。
キーワード引数は:

@table @code
@item epsrel
望まれる近似の相対誤差。デフォルトは1d-8。
@item epsabs
望まれる近似の絶対誤差。デフォルトは0。
@item limit
内部の作業配列のサイズ。 limitは使用する部分区間の最大数。デフォルトは200。
@end table

@code{quad_qagi}は４つの要素のリストを返します:

@itemize
@item
積分の近似
@item
見積もられた近似の絶対誤差
@item
非積分関数の評価数
@item
エラーコード
@end itemize

エラーコード(戻り値の４番目の要素)は以下の値を取ります:

@table @code
@item 0
問題が発生しなかった場合;
@item 1
部分区間の数が上限を超えた場合;
@item 2
丸め誤差が超過した場合;
@item 3
非積分関数の振る舞いが極端に悪い場合;
@item 4
収束に失敗した場合;
@item 5
積分が発散しているか収束が遅い場合;
@item 6
入力が無効な場合;
@end table

@c NEED CROSS REFS HERE -- EITHER CROSS REF A QUADPACK OVERVIEW, OR CROSS REF EACH OF THE quad_* FUNCTIONS

例:

@example
@group
(%i1) quad_qagi (x^2*exp(-4*x), x, 0, inf, 'epsrel=1d-8);
(%o1)        [0.03125, 2.95916102995002E-11, 105, 0]
@end group
@group
(%i2) integrate (x^2*exp(-4*x), x, 0, inf);
                               1
(%o2)                          --
                               32
@end group
@end example

@opencatbox
@category{Numerical methods} @category{Package quadpack}
@closecatbox
@end deffn

@c THERE ARE OPTIONAL ARGUMENTS WHICH MAKES LISTING THE VARIANTS A LITTLE TEDIOUS
@c NEED A MORE CONVENIENT (AND NONAMBIGUOUS) NOTATION FOR OPTIONAL ARGUMENTS

@c -----------------------------------------------------------------------------
@anchor{quad_qawc}
@deffn  {関数} quad_qawc @
@fname{quad_qawc} (@var{f(x)}, @var{x}, @var{c}, @var{a}, @var{b}, [@var{epsrel}, @var{epsabs}, @var{limit}]) @
@fname{quad_qawc} (@var{f}, @var{x}, @var{c}, @var{a}, @var{b}, [@var{epsrel}, @var{epsabs}, @var{limit}])

@math{f(x)/(x - c)}のコーシーの主値を有限の区間
@math{(a, b)}上で指定された @math{c}を用いて計算します。
戦略は大域的適応的で、点
@math{x = c}を含む部分範囲上で変形 Clenshaw-Curtis積分を使います。

@code{quad_qawc}は Quadpack QAWCルーチンを使って、
@ifnottex
@math{integrate (f(x)/(x - c), x, a, b)}
@end ifnottex
@tex
$$\int_{a}^{b}{{{f\left(x\right)}\over{x-c}}\>dx}$$
@end tex

のコーシーの主値を計算します。

被積分関数は従属変数 @var{x}の関数 @code{@var{f(x)}/(@var{x} - @var{c})}で、
関数は @var{a}から @var{b}までの区間上で積分されます。

被積分関数は Maximaか Lispの関数か演算子の名前であるか、
Maximaのラムダ式か Maximaの一般式として指定することができます。

キーワード引数は随意で、任意の順序で指定できます。
それらすべては形式 @code{key=val}を取ります。
キーワード引数は:

@table @code
@item epsrel
望まれる近似の相対誤差。デフォルトは1d-8。
@item epsabs
望まれる近似の絶対誤差。デフォルトは0。
@item limit
内部の作業配列のサイズ。limitは使用する部分区間の最大数。デフォルトは200。
@end table

@code{quad_qagc}は４つの要素のリストを返します:

@itemize
@item
積分の近似
@item
見積もられた近似の絶対誤差
@item
非積分関数の評価数
@item
エラーコード
@end itemize

エラーコード(戻り値の４番目の要素)は以下の値を取ります:

@table @code
@item 0
問題が発生しなかった場合;
@item 1
部分区間の数が上限を超えた場合;
@item 2
丸め誤差が超過した場合;
@item 3
非積分関数の振る舞いが極端に悪い場合;
@item 4
収束に失敗した場合;
@item 5
積分が発散しているか収束が遅い場合;
@item 6
入力が無効な場合;

@end table

例:

@example
@group
(%i1) quad_qawc (2^(-5)*((x-1)^2+4^(-5))^(-1), x, 2, 0, 5,
                 'epsrel=1d-7);
(%o1)    [- 3.130120337415925, 1.306830140249558E-8, 495, 0]
@end group
@group
(%i2) integrate (2^(-alpha)*(((x-1)^2 + 4^(-alpha))*(x-2))^(-1),
      x, 0, 5);
Principal Value
                       alpha
        alpha       9 4                 9
       4      log(------------- + -------------)
                      alpha           alpha
                  64 4      + 4   64 4      + 4
(%o2) (-----------------------------------------
                        alpha
                     2 4      + 2

       3 alpha                       3 alpha
       -------                       -------
          2            alpha/2          2          alpha/2
    2 4        atan(4 4       )   2 4        atan(4       )   alpha
  - --------------------------- - -------------------------)/2
              alpha                        alpha
           2 4      + 2                 2 4      + 2
@end group
@group
(%i3) ev (%, alpha=5, numer);
(%o3)                    - 3.130120337415917
@end group
@end example

@opencatbox
@category{Numerical methods} @category{Package quadpack}
@closecatbox
@end deffn

@c THERE ARE OPTIONAL ARGUMENTS WHICH MAKES LISTING THE VARIANTS A LITTLE TEDIOUS
@c NEED A MORE CONVENIENT (AND NONAMBIGUOUS) NOTATION FOR OPTIONAL ARGUMENTS

@c -----------------------------------------------------------------------------
@anchor{quad_qawf}
@deffn  {関数} quad_qawf @
@fname{quad_qawf} (@var{f(x)}, @var{x}, @var{a}, @var{omega}, @var{trig}, [@var{epsabs}, @var{limit}, @var{maxp1}, @var{limlst}]) @
@fname{quad_qawf} (@var{f}, @var{x}, @var{a}, @var{omega}, @var{trig}, [@var{epsabs}, @var{limit}, @var{maxp1}, @var{limlst}])

フーリエコサイン変換またはフーリエサイン変換を、
Quadpack QAWF関数を使って、半無限区間上で計算します。
@code{quad_qawo}で使われるのと同じアプローチが、連続する区間に適用され、
イプシロンアルゴリズム(Wynn, 1956)を使った収束の促進が積分寄与の級数に適用されます。

@code{quad_qawf}は積分
@ifnottex
@math{integrate (f(x)*w(x), x, a, inf)}
@end ifnottex
@tex
$$\int_a^\infty f(x) \, w(x) \, dx$$
@end tex
を計算します。

重み関数 @math{w}が @var{trig}によって以下のように選択されます:

@table @code
@item cos
@math{w(x) = cos (omega x)}
@item sin
@math{w(x) = sin (omega x)}
@end table

被積分関数は、 Maximaか Lispの関数か演算子の名前であるか、
Maximaのラムダ式か Maximaの一般式として指定することができます。

キーワード引数は随意で、任意の順序で指定できます。
それらすべては形式 @code{key=val}を取ります。
キーワード引数は:

@table @code
@item epsrel
望まれる近似の相対誤差。デフォルトは1d-8。
@item epsabs
望まれる近似の絶対誤差。デフォルトは0。
@item limit
内部の作業配列のサイズ。(@var{limit} - @var{limlst})/2は使用する部分区間の最大数。デフォルトは200。
@item maxp1
チェビシェフ積率の最大数。
0より大きくなければいけません。
デフォルトは100です。
@item limlst
サイクル数に関する上限。
3以上でなければいけません。
デフォルトは10です。
@end table

@code{quad_qawf}は４つの要素のリストを返します:

@itemize
@item
積分の近似
@item
見積もられた近似の絶対誤差
@item
非積分関数の評価数
@item
エラーコード
@end itemize

エラーコード(戻り値の４番目の要素)は以下の値を取ります:

@table @code
@item 0
問題が発生しなかった場合;
@item 1
部分区間の数が上限を超えた場合;
@item 2
丸め誤差が超過した場合;
@item 3
非積分関数の振る舞いが極端に悪い場合;
@item 4
収束に失敗した場合;
@item 5
積分が発散しているか収束が遅い場合;
@item 6
入力が無効な場合;

@end table

例:

@example
@group
(%i1) quad_qawf (exp(-x^2), x, 0, 1, 'cos, 'epsabs=1d-9);
(%o1)   [.6901942235215714, 2.84846300257552E-11, 215, 0]
@end group
@group
(%i2) integrate (exp(-x^2)*cos(x), x, 0, inf);
                          - 1/4
                        %e      sqrt(%pi)
(%o2)                   -----------------
                                2
@end group
@group
(%i3) ev (%, numer);
(%o3)                   .6901942235215714
@end group
@end example

@opencatbox
@category{Numerical methods} @category{Package quadpack}
@closecatbox
@end deffn

@c THERE ARE OPTIONAL ARGUMENTS WHICH MAKES LISTING THE VARIANTS A LITTLE TEDIOUS
@c NEED A MORE CONVENIENT (AND NONAMBIGUOUS) NOTATION FOR OPTIONAL ARGUMENTS

@c -----------------------------------------------------------------------------
@anchor{quad_qawo}
@deffn  {関数} quad_qawo @
@fname{quad_qawo} (@var{f(x)}, @var{x}, @var{a}, @var{b}, @var{omega}, @var{trig}, [@var{epsrel}, @var{epsabs}, @var{limit}, @var{maxp1}, @var{limlst}]) @
@fname{quad_qawo} (@var{f}, @var{x}, @var{a}, @var{b}, @var{omega}, @var{trig}, [@var{epsrel}, @var{epsabs}, @var{limit}, @var{maxp1}, @var{limlst}])

@ifnottex
@math{cos(omega x) f(x)}
@end ifnottex
@tex
$\cos\left(\omega \, x\right) \, f\left(x\right)$
@end tex
や
@ifnottex
@math{sin(omega x) f(x)}
@end ifnottex
@tex
$\sin\left(\omega \, x\right) \, f\left(x\right)$
@end tex
の有限の区間上の積分。
ここで、
@ifnottex
@math{omega}
@end ifnottex
@tex
$\omega$
@end tex
は定数です。
規則評価構成要素は変形 Clenshaw-Curtis手法に基づいています。
@code{quad_qawo}は@code{quad_qags}に似て、外挿とともに適応再分割を適用します。

@code{quad_qawo}は Quadpack QAWOルーチンを使って積分を計算します:

@ifnottex
@math{integrate (f(x)*w(x), x, a, b)}
@end ifnottex
@tex
$$\int_a^b f(x) \, w(x) \, dx$$
@end tex

重み関数 @math{w}が @var{trig}によって以下のように選択されます:

@table @code
@item cos
@ifnottex
@math{w(x) = cos (omega x)}
@end ifnottex
@tex
$w\left(x\right) = \cos \left(\omega \, x\right)$
@end tex
@item sin
@ifnottex
@math{w(x) = sin (omega x)}
@end ifnottex
@tex
$w\left(x\right) = \sin \left(\omega \, x\right)$
@end tex
@end table

被積分関数は Maximaか Lispの関数か演算子の名前であるか、
Maximaのラムダ式か Maximaの一般式として指定することができます。

キーワード引数は随意で、任意の順序で指定できます。
それらすべては形式 @code{key=val}を取ります。
キーワード引数は:

@table @code
@item epsrel
望まれる近似の相対誤差。デフォルトは1d-8。
@item epsabs
望まれる近似の絶対誤差。デフォルトは0。
@item limit
内部の作業配列のサイズ。@var{limit}/2は使用する部分区間の最大数。デフォルトは200。
@item maxp1
チェビシェフ積率の最大数。
0より大きくなければいけません。
デフォルトは100です。
@item limlst
サイクル数に関する上限。
3以上でなければいけません。
デフォルトは10です。
@end table

@code{quad_qawo}は４つの要素のリストを返します:

@itemize
@item
積分の近似
@item
見積もられた近似の絶対誤差
@item
非積分関数の評価数
@item
エラーコード
@end itemize

エラーコード(戻り値の４番目の要素)は以下の値を取ります:

@table @code
@item 0
問題が発生しなかった場合;
@item 1
部分区間の数が上限を超えた場合;
@item 2
丸め誤差が超過した場合;
@item 3
非積分関数の振る舞いが極端に悪い場合;
@item 4
収束に失敗した場合;
@item 5
積分が発散しているか収束が遅い場合;
@item 6
入力が無効な場合;
@end table

例:

@example
@group
(%i1) quad_qawo (x^(-1/2)*exp(-2^(-2)*x), x, 1d-8, 20*2^2, 1, cos);
(%o1)     [1.376043389877692, 4.72710759424899E-11, 765, 0]
@end group
@group
(%i2) rectform (integrate (x^(-1/2)*exp(-2^(-alpha)*x) * cos(x),
      x, 0, inf));
                   alpha/2 - 1/2            2 alpha
        sqrt(%pi) 2              sqrt(sqrt(2        + 1) + 1)
(%o2)   -----------------------------------------------------
                               2 alpha
                         sqrt(2        + 1)
@end group
@group
(%i3) ev (%, alpha=2, numer);
(%o3)                     1.376043390090716
@end group
@end example

@opencatbox
@category{Numerical methods} @category{Package quadpack}
@closecatbox
@end deffn

@c THERE ARE OPTIONAL ARGUMENTS WHICH MAKES LISTING THE VARIANTS A LITTLE TEDIOUS
@c NEED A MORE CONVENIENT (AND NONAMBIGUOUS) NOTATION FOR OPTIONAL ARGUMENTS

@c -----------------------------------------------------------------------------
@anchor{quad_qaws}
@deffn  {関数} quad_qaws @
@fname{quad_qaws} (@var{f(x)}, @var{x}, @var{a}, @var{b}, @var{alpha}, @var{beta}, @var{wfun}, [@var{epsrel}, @var{epsabs}, @var{limit}]) @
@fname{quad_qaws} (@var{f}, @var{x}, @var{a}, @var{b}, @var{alpha}, @var{beta}, @var{wfun}, [@var{epsrel}, @var{epsabs}, @var{limit}])

@math{w(x) f(x)}の有限の区間上の積分。
ここで @math{w(x)}はある代数的または対数関数です。
大域的適応最分割戦略が適用されます。
積分の区間の端点を含む部分区間上で変形 Clenshaw-Curtis積分を使います。

@code{quad_qaws}は Quadpack QAWSルーチンを使って積分を計算します:

@ifnottex
@math{integrate (f(x)*w(x), x, a, b)}
@end ifnottex
@tex
$$\int_a^b f(x) \, w(x) \, dx$$
@end tex

重み関数 @math{w}が @var{wfun}によって以下のように選択されます:

@table @code
@item 1
@ifnottex
@math{w(x) = (x - a)^alpha (b - x)^beta}
@end ifnottex
@tex
$w\left(x\right) = \left(x - a\right)^\alpha \, \left(b - x\right)^\beta$
@end tex
@item 2
@ifnottex
@math{w(x) = (x - a)^alpha (b - x)^beta log(x - a)}
@end ifnottex
@tex
$w\left(x\right) = \left(x - a\right)^\alpha \, \left(b - x\right)^\beta \, \log\left(x - a\right)$
@end tex
@item 3
@ifnottex
@math{w(x) = (x - a)^alpha (b - x)^beta log(b - x)}
@end ifnottex
@tex
$w\left(x\right) = \left(x - a\right)^\alpha \, \left(b - x\right)^\beta \, \log\left(b - x\right)$
@end tex
@item 4
@ifnottex
@math{w(x) = (x - a)^alpha (b - x)^beta log(x - a) log(b - x)}
@end ifnottex
@tex
$w\left(x\right) = \left(x - a\right)^\alpha \, \left(b - x\right)^\beta \, \log\left(x - a\right) \, \log\left(b - x\right)$
@end tex
@end table

被積分関数は Maximaか Lispの関数か演算子の名前であるか、
Maximaのラムダ式か Maximaの一般式として指定することができます。

キーワード引数は随意で、任意の順序で指定できます。
それらすべては形式 @code{key=val}を取ります。
キーワード引数は:

@table @code
@item epsrel
望まれる近似の相対誤差。デフォルトは1d-8。
@item epsabs
望まれる近似の絶対誤差。デフォルトは0。
@item limit
内部の作業配列のサイズ。 @var{limit}は使用する部分区間の最大数。デフォルトは200。
@end table

@code{quad_qaws}は４つの要素のリストを返します:

@itemize
@item
積分の近似
@item
見積もられた近似の絶対誤差
@item
非積分関数の評価数
@item
エラーコード
@end itemize

エラーコード(戻り値の４番目の要素)は以下の値を取ります:

@table @code
@item 0
問題が発生しなかった場合;
@item 1
部分区間の数が上限を超えた場合;
@item 2
丸め誤差が超過した場合;
@item 3
非積分関数の振る舞いが極端に悪い場合;
@item 4
収束に失敗した場合;
@item 5
積分が発散しているか収束が遅い場合;
@item 6
入力が無効な場合;

@end table

例:

@example
@group
(%i1) quad_qaws (1/(x+1+2^(-4)), x, -1, 1, -0.5, -0.5, 1,
                 'epsabs=1d-9);
(%o1)     [8.750097361672832, 1.24321522715422E-10, 170, 0]
@end group
@group
(%i2) integrate ((1-x*x)^(-1/2)/(x+1+2^(-alpha)), x, -1, 1);
       alpha
Is  4 2      - 1  positive, negative, or zero?

pos;
                          alpha         alpha
                   2 %pi 2      sqrt(2 2      + 1)
(%o2)              -------------------------------
                               alpha
                            4 2      + 2
@end group
@group
(%i3) ev (%, alpha=4, numer);
(%o3)                     8.750097361672829
@end group
@end example

@opencatbox
@category{Numerical methods} @category{Package quadpack}
@closecatbox
@end deffn

@c THERE ARE OPTIONAL ARGUMENTS WHICH MAKES LISTING THE VARIANTS A LITTLE TEDIOUS
@c NEED A MORE CONVENIENT (AND NONAMBIGUOUS) NOTATION FOR OPTIONAL ARGUMENTS

@c -----------------------------------------------------------------------------
@anchor{quad_qagp}
@deffn  {関数} quad_qagp @
@fname{quad_qagp} (@var{f(x)}, @var{x}, @var{a}, @var{b}, @var{points}, [@var{epsrel}, @var{epsabs}, @var{limit}]) @
@fname{quad_qagp} (@var{f}, @var{x}, @var{a}, @var{b}, @var{points}, [@var{epsrel}, @var{epsabs}, @var{limit}])

有限区間上の一般的な関数の積分。
@code{quad_qagp}は、
Epsilonアルゴリズム (Wynn, 1956)による外挿を使った大域的に適応的な区間部分分割
(de Doncker, 1978)を実装します。

@code{quad_qagp}は積分

@ifnottex
@math{integrate (f(x), x, a, b)}
@end ifnottex
@tex
$$\int_a^b {f(x) \, dx}$$
@end tex
を計算します。

被積分関数は従属変数 @var{x}を持つ @var{f(x)}で、
関数は端点 @var{a}と @var{b}の間で積分されます。

被積分関数は
Maximaか Lispの関数か演算子の名前か、Maximaのラムダ式、一般の Maxima式として
指定できます。

積分器を助けるため、
ユーザーは被積分関数の特異点や不連続点を提供しなければいけません。

キーワード引数はオプションで、
どんな順序でも指定できます。
それらはすべて @code{key=val}の形を取ります。
キーワード引数は以下の通りです:

@table @code
@item epsrel
所望の近似の相対誤差。デフォルトは 1d-8。
@item epsabs
所望の近似の絶対誤差。デフォルトは 0。
@item limit
内部の作業配列のサイズ。
@var{limit}は使われる部分区間の最大数です。
デフォルトは 200。
@end table

@code{quad_qagp}は4要素のリストを返します:

@itemize
@item
積分の近似,
@item
近似の絶対誤差の見積もり,
@item
被積分関数の評価数,
@item
エラーコード。
@end itemize

エラーコード(戻り値の４番目の要素)は以下の値を取ります:

@table @code
@item 0
問題が発生しなかった場合;
@item 1
部分区間の数が上限を超えた場合;
@item 2
丸め誤差が超過した場合;
@item 3
非積分関数の振る舞いが極端に悪い場合;
@item 4
収束に失敗した場合;
@item 5
積分が発散しているか収束が遅い場合;
@item 6
入力が無効な場合;

@end table

@c NEED CROSS REFS HERE -- EITHER CROSS REF A QUADPACK OVERVIEW, OR CROSS REF EACH OF THE quad_* FUNCTIONS

例:

@example
@group
(%i1) quad_qagp(x^3*log(abs((x^2-1)*(x^2-2))),x,0,3,[1,sqrt(2)]);
(%o1)   [52.74074838347143, 2.6247632689546663e-7, 1029, 0]
@end group
@group
(%i2) quad_qags(x^3*log(abs((x^2-1)*(x^2-2))), x, 0, 3);
(%o2)   [52.74074847951494, 4.088443219529836e-7, 1869, 0]
@end group
@end example

被積分関数は @code{1}と @code{sqrt(2)}で特異性を持つので
これらの点を @code{quad_qagp}に提供します。
@code{quad_qagp}は @mref{quad_qags}より精確で効率的であることも特筆します。

@opencatbox
@category{Numerical methods} @category{Package quadpack}
@closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@anchor{quad_control}
@deffn  {関数} quad_control (@var{parameter}, [@var{value}])

quadpackのエラーハンドリングを制御します。
パラメータは以下のシンボルのどれかでなければいけません:

@table @code
@item current_error
現在のエラー数
@item control
メッセージを印字するかしないか制御します。
ゼロ以下に設定すると、メッセージは抑制されます。
@item max_message
メッセージを印字する最大回数。
@end table

@var{value}を与えないと @var{parameter}の現在の値を返します。
@var{value}を与えると @var{parameter}の値に与えられた値を設定します。

@opencatbox
@category{Numerical methods} @category{Package quadpack}
@closecatbox
@end deffn
