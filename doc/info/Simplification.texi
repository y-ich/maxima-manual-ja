@c end concepts Simplification
@menu
* Introduction to Simplification::
* Functions and Variables for Simplification::
@end menu

@c -----------------------------------------------------------------------------
@node Introduction to Simplification, Functions and Variables for Simplification,  , Simplification
@section Introduction to Simplification
@c -----------------------------------------------------------------------------

@c -----------------------------------------------------------------------------
Maximaは、新しくユーザーがタイプしたコマンドそれぞれに対応してアクションのサイクルを実行します。
これは4つのステップからなります:入力を読み「パース」すること、評価、整理、そして出力。
パースは文法的に有効な一連のタイプされた文字を操作の残りで使うデータ構造に変換します。
評価は名前を割り当てられた値に置き換えます。
整理は式をユーザーや他のプログラムがより理解しやすいように書き直すことを意味します。
出力は様々な異なるフォーマットや記法で計算結果を表示することを含みます。

評価や整理は、どちらも「複雑さ」を取り除くことがゴールなので、時々、似た機能を持つように見えます。
システム設計者は時々、それぞれで部分的に実行されるようにタスクを分割します。
例えば、 @code{integrate(x,x)}は答えを @code{x*x/2}と評価し、それは、 @code{x^2/2}に整理されます。

評価はいつも存在します: それは、関数、サブルーチン、変数、値、ループ、割り当てなどを持つプログラミングシステムを持つことの
結果です。
評価ステップでは、組み込みかユーザー定義の関数名はそれらの定義に置き換えられ、変数はそれらの値に置き換えられます。
これは、従来のプログラミング言語の活動と大部分同じですが、
記号数学データも扱うように拡張されました。
目下の数学の汎用性のため、異なる可能な評価モデルがあり、
システムは評価のプロセスの舵をとるオプションの「フラグ」を持ちます。
@xref{Functions and Variables for Evaluation}

対照的に、整理の意図は、表現を再再定式化して、より小さく、理解しやすく、
(因数分解や展開のように)特定の仕様に準じるように式の値を整備することです。
例えば、　 @code{sin(0)}は @code{0}に、 @code{x+x}は @code{2*x}に。
整理の結果を変えるいくつかの強力なツールがあります。
新しく導入された関数や記号記法の知識をユーザーがMaximaに取り込むことができることの大半はシステムのこの部分だからです。

整理は一般に4つの異なるレベルで行われます:
@itemize @bullet
@item 内部の組み込み自動整理器、
@item プログラムやコマンド列の中の特定の場所でユーザーが明示的にコールすることができる組み込み整理ルーチン、
@item "tellsimp"や "tellsimpafter"を使って整理器とリンクされ、自動的にコールされるユーザーが書いた整理ルーチン、
@item プログラムやコマンド列の中の特定の場所でユーザーが明示的にコールすることができるユーザーが書いた整理ルーチン、
@end itemize
内部の整理器はMaximaの心臓部に属します。
それは大きく複雑なプログラムの集まりであり、何年にも渡って数千のユーザーの手で改良され続けています。
それでもやはり、特に、新しいアイデアや従来とは違う記法を試すなら、
自分自身でプログラムに小さな(また大きな)変更を加えることが役に立つことがわかるかもしれません。
詳細は例えば、
@url{https://people.eecs.berkeley.edu/~fateman/papers/intro5.txt}
の終わりの論文を参照してください。

Maximaは内部的に、演算子を使った「ツリー」として、すなわち
@code{+}, @code{*} , @code{=}のような「ルート」と、@var{x}, @var{y}, @var{z}のような変数や 関数、
@code{x*y}のようなサブツリーである演算数(「リーフ」)で式を表現します。
演算子それぞれはそれと連携した整理プログラムを持ちます。
@code{+}(これは@code{a-b = a+(-1)*b)}なので二項演算子 @code{-}もカバーします)と
@code{*}(これは@code{a/b = a*b^(-1)}なので二項演算子 @code{/}もカバーします)
はかなり込み入った整理プログラムを持ちます。
これらの整理プログラム(simplus, simptimes, simpexptなど)は
整理器が解析中の式ツリーの中でそれぞれの算術演算子を見つけると常にコールされます。

整理器の構造は1965年まで遡り、以来多くの手が加えられています。
その構造は現代の専門用語で言うと、データ指示でオブジェクト指向です。
プログラムは、式の、あるサブツリーの根に依存して適切なルーチンを再帰的に送ります。
この汎用の概念は、
プログラムへの非常に局所的な変更で整理プロセスへの修正を行うことができることを意味します。
多くの場合、既存のコードを乱すことなく演算子とその整理器を追加することは概念的に簡単です。

代数式ツリーに演算するこの汎用の整理器に加えて、
Maximaの式のいくつかの他の表現がメソッドと整理器を分離することに注意を払います。
例えば、@code{rat()}関数は、そんな形式の高速な操作を助けるために、多項式を係数のベクトルに変換します。
他の表現にはTaylor級数や(滅多に使われない)Poisson級数があります。

ユーザーが導入するすべての演算子は、初期状態としてそれらと連携した整理器を持ちません。
Maximaは関数"f"に関して何も知らないので、 @code{f(a,b)}とタイプすると、
@var{a}, @var{b}は整理されますが、 @code{f}については整理されません。
いくつかの組み込み演算子でさえ整理器を持たないものがあります。
例えば、 @code{=}は「整理」しません。 -- それは、
この場合左辺と右辺を参照する2つの引数を整理する以上の整理セマンティクスを持たないプレイスホルダです
解答プログラムのようなMaximaの他の部分は等式
、すなわち、 @code{=}を根に持つツリーに特別な注意を払います。
(注意 -- Maximaでは、割り当て演算は @code{:}です。
すなわち、 @code{q: 4}はシンボル @var{q}の値に @code{4}を設定します。
関数定義には @code{:=}を使います。)

汎用整理器は、式と部分式それぞれが整理されたことを示す内部フラグと一緒に結果を返します。
これは、すべての可能な等価式上でそれが唯一であることを保証しません。
それは困難すぎます。(理論的に、Maximaで表現可能なものの一般性を仮定して不可能です)
しかし、和や積の中の項の順序など、式のいくつかの面では一貫しています。
これは他のプログラムが適切に動作するために重要です。

Maximaの処理をゴールとして特定の好みの種類のパターンに導くたくさんのオプション変数を設定できます。
simp:falseで整理器をオフにする最も極端なオプションを使うことさえできます。
多くの内部ルーチンは引数が整理されていることを仮定しているので、これはお勧めしません。
(整理器をオフにするにが尤もらしくみえる唯一のケースは、組み込み整理器をオーバーライドしたいという稀なケースです。
その場合、一時的に整理器をオフにして、 @mrefcomma{tellsimp}経由で新しい変換に置き換え、
そして @code{simp:true}で整理器を再度オンにするかもしれません)

あなたがユーザー定義のシンボル関数名や演算子をプロパティ (@mref{additive},
@mref{lassociative}, @mref{oddfun}, @mref{antisymmetric},
@mref{linear}, @mref{outative}, @mref{commutative},
@mref{multiplicative}, @mref{rassociative}, @mref{evenfun},
@mref{nary}, @mref{symmetric})と連携させることはさらに尤もらしいです。
これらのオプションは処理する整理器をシステマティックな指示で操作します。

例えば、 @code{declare(f,oddfun)}は、 @code{f}を奇関数と規定します。
Maximaは @code{f(-x)}を @code{-f(x)}に整理するでしょう。
偶関数の場合、それは @code{declare(g,evenfun)}であり、
Maximaは @code{g(-x)}を @code{g(x)}に整理するでしょう。
@code{h(x):=x^2+1}といったようにプログラミング関数を名前に関連づけることもできます。
その場合、評価器はすぐに @code{h(3)}を @code{10}に、
@code{h(a+1)}を @code{(a+1)^2+1}に置き換え、 @code{h}のどんなプロパティも無視されます。

ユーザーが設定したこれらの直接関連したプロパティに加えて、
実際の文脈からのファクトやプロパティも
整理器の振る舞いに影響を与えるかもしれません。
@xref{Introduction to Maximas Database}

例: もし @var{n}が整数なら、 @code{sin(n*%pi)}は零に整理されます。

@c ===beg===
@c sin(n*%pi);
@c declare(n, integer);
@c sin(n*%pi);
@c ===end===
@example
@group
(%i1) sin(n*%pi);
(%o1)                      sin(%pi n)
@end group
@group
(%i2) declare(n, integer);
(%o2)                         done
@end group
@group
(%i3) sin(n*%pi);
(%o3)                           0
@end group
@end example

もし自動整理が不十分なら、
組み込みだけれでも明示的に呼び出す整理関数 (@mref{ratsimp},
@mref{expand}, @mref{factor}, @mref{radcan}, その他)を検討できます。
整理をあれこれの方向に進めるフラグもあります。
@code{demoivre:true}を与えると、整理器は複素指数を三角関数形式に書き換えます。
@code{exponentialize:true}を与えると、整理器は逆を試みます:
三角関数形式を複素指数に。

Maximaのどこでも、
(Maximaユーザー言語でも実装言語のLispでも)自身の関数を書いてプログラムの中の選んだ場所で明示的に呼び出すことで
個人的な整理の必要性に応えることができます。
Lispはあなたに内部メカニズムすべてのハンドルを与えますが、めったにこの最大限の汎用性は必要としないでしょう。
"Tellsimp"は 整理機への Lisp内部インタフェースの多くを自動的に生成するように設計されています。
@xref{Rules and Patterns}を参照してください。

何年にも渡って(Maxima/Macsymaの起源は1966年まで遡ります！)
ユーザーは関数的な振る舞いを拡張したり変えたりするたくさんの応用パッケージやツールを貢献し続けています。
整理を修正したり拡張したりするための様々な非標準の「共有」パッケージも存在します。
現在も進行中の実験的な材料 @xref{simplification-pkg}も見てみてください。

以下の追加された材料は初めて読む時には必須ではありません。
以下を読むことはMaximaの生産的な利用に必要ではありません。
何が起こっているのか知りたい好奇心あるユーザーや
(オープンソース)コードを変更したい野心的なプログラマーのためです。
Maxima Lispコードを再定義する実験は簡単に可能です:
Lispプログラム(例えば、 @code{cos()}を整理する @code{simp%cos}だとしましょう)の定義を変えるには、
Maximaのテキストファイルを覗き込んで、 maximaパッケージから @code{simp%cos}関数を書き換えるだけです。

@c -----------------------------------------------------------------------------
@node Functions and Variables for Simplification,  , Introduction to Simplification, Simplification
@section Functions and Variables for Simplification
@c -----------------------------------------------------------------------------

@c -----------------------------------------------------------------------------
@anchor{additive}
@defvr {プロパティ} additive

もし @code{declare(f, additive)}が実行されると:

(1) もし @code{f}が1変数関数なら、 @code{f}が和に適用された時はいつでも
@code{f}は和の上に分配整理されます。
例えば、 @code{f(y+x)}は、 @code{f(y)+f(x)}に整理されます。

(2) もし @code{f}が2変数以上の関数なら、
@code{sum}や @code{integrate}の場合と同様に
加法性が第一番目の引数に対して定義されます。
例えば、 @code{f(h(x)+g(x),x)}は @code{f(h(x),x)+f(g(x),x)}に整理されます。
@code{f}が @code{sum(x[i],i,lower-limit,upper-limit)}の形の式に適用されたときには
この整理はされません。

例:

@c ===beg===
@c F3 (a + b + c);
@c declare (F3, additive);
@c F3 (a + b + c);
@c ===end===
@example
@group
(%i1) F3 (a + b + c);
(%o1)                     F3(c + b + a)
@end group
@group
(%i2) declare (F3, additive);
(%o2)                         done
@end group
@group
(%i3) F3 (a + b + c);
(%o3)                 F3(c) + F3(b) + F3(a)
@end group
@end example

@opencatbox
@category{Operators} @category{Declarations and inferences}
@closecatbox
@end defvr

@c -----------------------------------------------------------------------------
@anchor{antisymmetric}
@defvr {プロパティ} antisymmetric

もし @code{declare(h,antisymmetric)}が実行されると、
@code{h}は反対称として整理されます。
例えば、 @code{h(x,z,y)}は @code{-h(x,y,z)}と整理されます。
即ち、 @code{symmetric}か
@code{commutative}で得られた結果に(-1)^nを掛けたものとなります。
ここでnはその形に変換するのに必要な置換の回数です。

例:

@c ===beg===
@c S (b, a);
@c declare (S, symmetric);
@c S (b, a);
@c S (a, c, e, d, b);
@c T (b, a);
@c declare (T, antisymmetric);
@c T (b, a);
@c T (a, c, e, d, b);
@c ===end===
@example
@group
(%i1) S (b, a);
(%o1)                        S(b, a)
@end group
@group
(%i2) declare (S, symmetric);
(%o2)                         done
@end group
@group
(%i3) S (b, a);
(%o3)                        S(a, b)
@end group
@group
(%i4) S (a, c, e, d, b);
(%o4)                   S(a, b, c, d, e)
@end group
@group
(%i5) T (b, a);
(%o5)                        T(b, a)
@end group
@group
(%i6) declare (T, antisymmetric);
(%o6)                         done
@end group
@group
(%i7) T (b, a);
(%o7)                       - T(a, b)
@end group
@group
(%i8) T (a, c, e, d, b);
(%o8)                   T(a, b, c, d, e)
@end group
@end example

@opencatbox
@category{Operators} @category{Declarations and inferences}
@closecatbox
@end defvr

@c -----------------------------------------------------------------------------
@deffn {関数} combine (@var{expr})
同じ分母を持つ項を単一の項に結合することによって和 @var{expr}を整理します。

例:

@c ===beg===
@c 1*f/2*b + 2*c/3*a + 3*f/4*b +c/5*b*a;
@c combine (%);
@c ===end===
@example
@group
(%i1) 1*f/2*b + 2*c/3*a + 3*f/4*b +c/5*b*a;
                      5 b f   a b c   2 a c
(%o1)                 ----- + ----- + -----
                        4       5       3
@end group
@group
(%i2) combine (%);
                  75 b f + 4 (3 a b c + 10 a c)
(%o2)             -----------------------------
                               60
@end group
@end example

@opencatbox
@category{Expressions}
@closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@anchor{commutative}
@defvr {プロパティ} commutative

もし @code{declare(h,commutative)}が実行されたなら、
@code{h}は可換関数として整理されます。
例えば、 @code{h(x,z,y)}は @code{h(x,y,z)}に整理されます。
これは @code{symmetric}と同じです。

例:

@c ===beg===
@c S (b, a);
@c S (a, b) + S (b, a);
@c declare (S, commutative);
@c S (b, a);
@c S (a, b) + S (b, a);
@c S (a, c, e, d, b);
@c ===end===
@example
@group
(%i1) S (b, a);
(%o1)                        S(b, a)
@end group
@group
(%i2) S (a, b) + S (b, a);
(%o2)                   S(b, a) + S(a, b)
@end group
@group
(%i3) declare (S, commutative);
(%o3)                         done
@end group
@group
(%i4) S (b, a);
(%o4)                        S(a, b)
@end group
@group
(%i5) S (a, b) + S (b, a);
(%o5)                       2 S(a, b)
@end group
@group
(%i6) S (a, c, e, d, b);
(%o6)                   S(a, b, c, d, e)
@end group
@end example

@opencatbox
@category{Operators} @category{Declarations and inferences}
@closecatbox
@end defvr

@c NEEDS CLARIFICATION, EXAMPLES

@c -----------------------------------------------------------------------------
@anchor{demoivre}
@deffn  {関数} demoivre (@var{expr})
@deffnx {オプション変数} demoivre

関数 @code{demoivre (expr)}は
グローバル変数 @code{demoivre}を設定することなく式を変換します。

変数 @code{demoivre}が　@code{true}の時、
複素数の指数関数は円関数の項で表した同値な式に変換されます:
もし　@code{b}が　@code{%i}を含まないなら、
@code{exp (a + b*%i)}は @code{%e^a * (cos(b) + %i*sin(b))}に整理されます。
@code{a}と @code{b}は展開されません。

@code{demoivre}のデフォルト値は @code{false}です。

@code{exponentialize}は円関数や双曲関数を指数関数形に変換します。
@code{demoivre}と @code{exponentialize}は同時に両方trueにはできません。

@opencatbox
@category{Complex variables} @category{Trigonometric functions} @category{Hyperbolic functions}
@closecatbox
@end deffn

@c NEEDS WORK

@c -----------------------------------------------------------------------------
@anchor{function_distrib}
@deffn {関数} distrib (@var{expr})

和を積上に分配します。
式のトップレベルのみで働きます。
すなわち、再帰的でなく @code{expand}より速い点で @code{expand}とは違います。
トップレベルの和すべてを展開する点で @code{multthru}とは違います。

例:

@example
(%i1) distrib ((a+b) * (c+d));
(%o1)                 b d + a d + b c + a c
(%i2) multthru ((a+b) * (c+d));
(%o2)                 (b + a) d + (b + a) c
(%i3) distrib (1/((a+b) * (c+d)));
                                1
(%o3)                    ---------------
                         (b + a) (d + c)
(%i4) expand (1/((a+b) * (c+d)), 1, 0);
                                1
(%o4)                 ---------------------
                      b d + a d + b c + a c
@end example

@opencatbox
@category{Expressions}
@closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@anchor{distribute_over}
@defvr {オプション変数} distribute_over
デフォルト値: @code{true}

@code{distribute_over}は
リストや行列や等式のようなバッグ(重複を許す集合)上の関数のマッピングを制御します。
今回、すべてのMaxima関数がこのプロパティを持つ訳ではありません。
このプロパティはコマンド @code{properties}で調べることが可能です。

@code{distribute_over}を値 @code{false}に設定した時、
関数のマッピングはオフにスイッチされます。

例:

@code{sin}関数はリスト上にマップします:

@c ===beg===
@c sin([x,1,1.0]);
@c ===end===
@example
@group
(%i1) sin([x,1,1.0]);
(%o1)         [sin(x), sin(1), 0.8414709848078965]
@end group
@end example

@code{mod}は
リスト上にマップされる２変数関数です。
入れ子のリスト上のマッピングも可能です:

@c ===beg===
@c mod([x,11,2*a],10);
@c mod([[x,y,z],11,2*a],10);
@c ===end===
@example
@group
(%i1) mod([x,11,2*a],10);
(%o1)             [mod(x, 10), 1, 2 mod(a, 5)]
@end group
@group
(%i2) mod([[x,y,z],11,2*a],10);
(%o2) [[mod(x, 10), mod(y, 10), mod(z, 10)], 1, 2 mod(a, 5)]
@end group
@end example

@code{floor}関数の行列や等式上のマッピング:

@c ===beg===
@c floor(matrix([a,b],[c,d]));
@c floor(a=b);
@c ===end===
@example
@group
(%i1) floor(matrix([a,b],[c,d]));
                     [ floor(a)  floor(b) ]
(%o1)                [                    ]
                     [ floor(c)  floor(d) ]
@end group
@group
(%i2) floor(a=b);
(%o2)                  floor(a) = floor(b)
@end group
@end example

１変数以上の関数は任意の引数上、または、すべての引数上にマップします:

@c ===beg===
@c expintegral_e([1,2],[x,y]);
@c ===end===
@example
@group
(%i1) expintegral_e([1,2],[x,y]);
(%o1) [[expintegral_e(1, x), expintegral_e(1, y)],
                      [expintegral_e(2, x), expintegral_e(2, y)]]
@end group
@end example

関数がプロパティdistribute_overを持つかチェックします:

@c ===beg===
@c properties(abs);
@c ===end===
@example
@group
(%i1) properties(abs);
(%o1) [integral, rule, distributes over bags, noun, gradef,
                                                 system function]
@end group
@end example

@code{distribute_over}を @code{false}値に設定すると、
関数の展開はオフになります。

@c ===beg===
@c distribute_over;
@c sin([x,1,1.0]);
@c distribute_over : not distribute_over;
@c sin([x,1,1.0]);
@c ===end===
@example
@group
(%i1) distribute_over;
(%o1)                         true
@end group
@group
(%i2) sin([x,1,1.0]);
(%o2)         [sin(x), sin(1), 0.8414709848078965]
@end group
@group
(%i3) distribute_over : not distribute_over;
(%o3)                         false
@end group
@group
(%i4) sin([x,1,1.0]);
(%o4)                   sin([x, 1, 1.0])
@end group
@end example

@opencatbox
@category{Simplification flags and variables}
@closecatbox
@end defvr

@c -----------------------------------------------------------------------------
@anchor{domain}
@defvr {オプション変数} domain
デフォルト値: @code{real}

@code{domain}が @code{complex}に設定されている時、
@code{sqrt (x^2)}は @code{abs(x)}を返さず
@code{sqrt (x^2)}のままを保ちます。

@c PRESERVE EDITORIAL COMMENT -- MAY HAVE SOME SIGNIFICANCE NOT YET UNDERSTOOD !!!
@c The notion of a "domain" of simplification is still in its infancy,
@c and controls little more than this at the moment.

@opencatbox
@category{Simplification flags and variables}
@closecatbox
@end defvr

@c -----------------------------------------------------------------------------
@anchor{evenfun}
@anchor{oddfun}
@defvr  {プロパティ} evenfun
@defvrx {プロパティ} oddfun

@code{declare(f, evenfun)}や @code{declare(f, oddfun)}は
関数 @code{f}を偶関数か奇関数として認識するように命じます。

例:

@example
(%i1) o (- x) + o (x);
(%o1)                     o(x) + o(- x)
(%i2) declare (o, oddfun);
(%o2)                         done
(%i3) o (- x) + o (x);
(%o3)                           0
(%i4) e (- x) - e (x);
(%o4)                     e(- x) - e(x)
(%i5) declare (e, evenfun);
(%o5)                         done
(%i6) e (- x) - e (x);
(%o6)                           0
@end example
@end defvr

@c -----------------------------------------------------------------------------
@anchor{expand}
@deffn  {関数} expand @
@fname{expand} (@var{expr}) @
@fname{expand} (@var{expr}, @var{p}, @var{n})

式@var{expr}を展開します。
指数和や和の積の積を実行し、有理式の分子をそれぞれの項に分割し、
（可換、非可換な）積が @var{expr}のすべてのレベルの和で分配されます。

多項式の場合、通常もっと効率的なアルゴリズムの @code{ratexpand}を使うべきです。

@code{maxnegex}と @code{maxposex}はそれぞれ、展開される最大の負と正の指数を制御します。

@code{expand (expr, p, n)}は
@var{expr}を、　@code{maxposex}に @var{p}を @code{maxnegex}に
@var{n}を使って展開します。
これは式のすべてではなく、一部を展開するために役立ちます。

@code{expon} - 自動的に展開される最大の負のべきの指数 (@code{expand}のコールに独立して)。
例えば、もしも @code{expon}が4なら @code{(x+1)^(-5)}は自動では展開されません。

@code{expop} - 自動的に展開される最大の正の指数。
もし @code{expop}が3以上なら @code{(x+1)^3}は自動的に展開されます。
もし @code{n}が @code{expop}よりも大きい時 @code{(x+1)^n}が展開されるのが望まれるなら、
@code{maxposex}が @code{n}より小さくない場合のみ
@code{expand ((x+1)^n)}の実行が行われます。

@code{expand(expr, 0, 0)}は @code{expr}を再整理します。
@code{expr}は再評価はされません。
@code{ev(expr, noeval)}との違いは、
特殊な表現(例えばCRE形式)が削除されることです。
@mref{ev}も参照してください。

@code{ev}で使われる @code{expand}フラグによって展開が実行されます。

ファイル@file{share/simplification/facexp.mac}は、
@c I should really use a macro which expands to something like
@c @uref{file://...,,simplification/facexp.mac}.  But texi2html
@c currently supports @uref only with one argument.
@c Worse, the `file:' scheme is OS and browser dependent.
ユーザーに制御された展開によって式を構成する機能を提供するいくつかの関連関数
（特に自動ロードされる @code{facsum}, @code{factorfacsum}, @code{collectterms}）と
変数(@code{nextlayerfactor}, @code{facsum_combine})を含みます。
@c MERGE share/simplification/facexp.usg INTO THIS FILE OR CREATE NEW FILE facexp.texi
簡単な関数の記述が @file{simplification/facexp.usg}にあります。
@code{demo("facexp")}でデモが実行できます。

例:

@c ===beg===
@c expr:(x+1)^2*(y+1)^3;
@c expand(expr);
@c expand(expr,2);
@c expr:(x+1)^-2*(y+1)^3;
@c expand(expr);
@c expand(expr,2,2);
@c ===end===
@example
@group
(%i1) expr:(x+1)^2*(y+1)^3;
                               2        3
(%o1)                   (x + 1)  (y + 1)
@end group
@group
(%i2) expand(expr);
       2  3        3    3      2  2        2      2      2
(%o2) x  y  + 2 x y  + y  + 3 x  y  + 6 x y  + 3 y  + 3 x  y
                                                      2
                                     + 6 x y + 3 y + x  + 2 x + 1
@end group
@group
(%i3) expand(expr,2);
               2        3              3          3
(%o3)         x  (y + 1)  + 2 x (y + 1)  + (y + 1)
@end group
@group
(%i4) expr:(x+1)^-2*(y+1)^3;
                                   3
                            (y + 1)
(%o4)                       --------
                                   2
                            (x + 1)
@end group
@group
(%i5) expand(expr);
            3               2
           y             3 y            3 y             1
(%o5) ------------ + ------------ + ------------ + ------------
       2              2              2              2
      x  + 2 x + 1   x  + 2 x + 1   x  + 2 x + 1   x  + 2 x + 1
@end group
@group
(%i6) expand(expr,2,2);
                                   3
                            (y + 1)
(%o6)                     ------------
                           2
                          x  + 2 x + 1
@end group
@end example

展開なしに式を再整理します:

@c ===beg===
@c expr:(1+x)^2*sin(x);
@c exponentialize:true;
@c expand(expr,0,0);
@c ===end===
@example
@group
(%i1) expr:(1+x)^2*sin(x);
                                2
(%o1)                    (x + 1)  sin(x)
@end group
@group
(%i2) exponentialize:true;
(%o2)                         true
@end group
@group
(%i3) expand(expr,0,0);
                            2    %i x     - %i x
                  %i (x + 1)  (%e     - %e      )
(%o3)           - -------------------------------
                                 2
@end group
@end example

@opencatbox
@category{Expressions}
@closecatbox
@end deffn

@c NEEDS EXAMPLES

@c -----------------------------------------------------------------------------
@anchor{expandwrt}
@deffn {関数} expandwrt (@var{expr}, @var{x_1}, ..., @var{x_n})

式@code{expr}を変数 @var{x_1}, ..., @var{x_n}に関して展開します。
変数を含む積すべては明示的に現れます。
返される形式は変数を含む式の和の積を含みません。
@var{x_1}, ..., @var{x_n}は変数、演算子、式であり得ます。

デフォルトでは分母は展開されませんが、これはスイッチ @code{expandwrt_denom}によって
制御することができます。

この関数は @file{simplification/stopex.mac}から自動ロードされます。

@opencatbox
@category{Expressions}
@closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@anchor{expandwert_denom}
@defvr {オプション変数} expandwrt_denom
デフォルト値: @code{false}

@code{expandwrt_denom}は @code{expandwrt}によって有理式の扱いを制御します。
もし @code{true}なら式の分子も分母も @code{expandwrt}の引数に従って展開されますが、
もし @code{expandwrt_denom}が @code{false}なら分子だけがその方法で展開されます。

@opencatbox
@category{Expressions}
@closecatbox
@end defvr

@c NEEDS A STAND-ALONE DESCRIPTION (NOT "IS SIMILAR TO")
@c NEEDS EXAMPLES
@c -----------------------------------------------------------------------------
@anchor{expandwrt_factored}
@deffn {関数} expandwrt_factored (@var{expr}, @var{x_1}, ..., @var{x_n})

@code{expandwrt}に似ていますが、積の式を幾分違って扱います。
@code{expandwrt_factored}は、
変数 @var{x_1}, ..., @var{x_n}を含む @code{expr}の因子上でだけ展開します。

@c NOT SURE WHY WE SHOULD MENTION THIS HERE
この関数は @file{simplification/stopex.mac}から自動ロードされます。

@opencatbox
@category{Expressions}
@closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@anchor{expon}
@defvr {オプション変数} expon
デフォルト値: 0

@code{expon}は、(@code{expand}のコールに依らず)自動的に展開される負のべき乗の最大指数です。
例えば、
もし@code{expon}が4なら
@code{(x+1)^(-5)}は自動的には展開されません。

@opencatbox
@category{Expressions}
@closecatbox
@end defvr


@c -----------------------------------------------------------------------------
@anchor{exponentialize}
@deffn {関数} exponentialize (@var{expr})
@deffnx {オプション変数} exponentialize

関数 @code{exponentialize (expr)}は
@var{expr}の中の円関数や双曲関数を指数関数に変換します。
グローバル変数 @code{exponentialize}を設定する必要はありません。

変数 @code{exponentialize}が @code{true}の時、
円関数や双曲関数すべては指数関数形に変換されます。
デフォルト値は @code{false}です。

@code{demoivre}は複素数の指数関数を円関数に変換します。
@code{exponentialize}や @code{demoivre}は同時にtrueにすることはできません。

@opencatbox
@category{Complex variables} @category{Trigonometric functions} @category{Hyperbolic functions}
@closecatbox
@end deffn

@c NEEDS CLARIFICATION
@c NEEDS EXAMPLES

@c -----------------------------------------------------------------------------
@anchor{expop}
@defvr {オプション変数} expop
デフォルト値: 0

@code{expop}は自動的に展開される最大の正の指数です。
例えば、 @code{(x + 1)^3}が入力された時、
@code{expop}が3以下の時だけ自動的に展開されます。
もし @code{n}が @code{expop}より大きい @code{(x + 1)^n}が展開されることを望むなら、
@code{maxposex}がn以上の時だけ
@code{expand ((x + 1)^n)}を実行するとうまくいきます。

@opencatbox
@category{Expressions}
@closecatbox
@end defvr

@c NEEDS CLARIFICATION, EXAMPLES
@c -----------------------------------------------------------------------------
@anchor{lassociative}
@defvr {プロパティ} lassociative

@code{declare (g, lassociative)}は
Maximaの整理器に
@code{g}が左結合であることを知らせます。
例えば、 @code{g (g (a, b), g (c, d))}は
@code{g (g (g (a, b), c), d)}に整理されます。

@opencatbox
@category{Declarations and inferences} @category{Operators} @category{Simplification}
@closecatbox
@end defvr

@c NEEDS CLARIFICATION, EXAMPLES
@c WHAT'S UP WITH THE QUOTE MARKS ??

@c -----------------------------------------------------------------------------
@anchor{linear}
@defvr {プロパティ} linear

Maximaの演算子のプロパティの１つ。
そう宣言された1変数関数 @code{f}に関して、
@code{f(x + y)}の「展開」は @code{f(x) + f(y)}を出力し、
@code{a}が定数の@code{f(a*x)}は @code{a*f(x)}を出力します。
２つ以上の引数の関数に関しては、
「線形性」は @code{sum}や @code{integrate}の場合のように定義されます。
すなわち、 @code{a}と @code{b}が@code{x}に独立の場合，
@code{f (a*x + b, x)}は @code{a*f(x,x) + b*f(1,x)}を出力します。

例:

@c ===beg===
@c declare (f, linear);
@c f(x+y);
@c declare (a, constant);
@c f(a*x);
@c ===end===
@example
@group
(%i1) declare (f, linear);
(%o1)                         done
@end group
@group
(%i2) f(x+y);
(%o2)                      f(y) + f(x)
@end group
@group
(%i3) declare (a, constant);
(%o3)                         done
@end group
@group
(%i4) f(a*x);
(%o4)                        a f(x)
@end group
@end example

@code{linear}は @code{additive}かつ @code{outative}と同値です。
@mref{opproperties}も参照してください。

例:

@c ===beg===
@c 'sum (F(k) + G(k), k, 1, inf);
@c declare (nounify (sum), linear);
@c 'sum (F(k) + G(k), k, 1, inf);
@c ===end===
@example
@group
(%i1) 'sum (F(k) + G(k), k, 1, inf);
                       inf
                       ====
                       \
(%o1)                   >    (G(k) + F(k))
                       /
                       ====
                       k = 1
@end group
@group
(%i2) declare (nounify (sum), linear);
(%o2)                         done
@end group
@group
(%i3) 'sum (F(k) + G(k), k, 1, inf);
                     inf          inf
                     ====         ====
                     \            \
(%o3)                 >    G(k) +  >    F(k)
                     /            /
                     ====         ====
                     k = 1        k = 1
@end group
@end example

@opencatbox
@category{Declarations and inferences} @category{Operators} @category{Simplification}
@closecatbox
@end defvr

@c NEEDS EXAMPLES

@c -----------------------------------------------------------------------------
@anchor{maxnegex}
@defvr {オプション変数} maxnegex
デフォルト値: 1000

@code{maxnegex}は
@code{expand}コマンドによって展開される最大の負の指数です。
（@mref{maxposex})も参照してください。）

@opencatbox
@category{Expressions}
@closecatbox
@end defvr

@c NEEDS EXAMPLES

@c -----------------------------------------------------------------------------
@anchor{maxposex}
@defvr {オプション変数} maxposex
デフォルト値: 1000

@code{maxposex}は
@code{expand}コマンドで展開される最大指数です。
（@mref{maxnegex})も参照してください。）

@opencatbox
@category{Expressions}
@closecatbox
@end defvr

@c NEEDS EXAMPLES

@c -----------------------------------------------------------------------------
@anchor{multiplicative}
@defvr {プロパティ} multiplicative

@code{declare (f, multiplicative)}は Maxima整理器に
@code{f}が乗法的であることを知らせます。

@enumerate
@item
もし @code{f}が１変数関数なら、
整理器が積に適用された @code{f}に出会うといつでも、
@code{f}はその積上に分配されます。
例えば、 @code{f(x*y)}は @code{f(x)*f(y)}に整理されます。
この整理は形式 @code{f('product(...))}の式には適用されません。
@item
もし @code{f}が多変数関数なら、
乗法性は @code{f}の最初の引数の乗法性として定義されます。
例えば、
@code{f (g(x) * h(x), x)}は @code{f (g(x) ,x) * f (h(x), x)}に整理されます。
@end enumerate

@code{declare(nounify(product), multiplicative)}はMaximaに記号積を整理するように命じます。

例:

@c ===beg===
@c F2 (a * b * c);
@c declare (F2, multiplicative);
@c F2 (a * b * c);
@c ===end===
@example
@group
(%i1) F2 (a * b * c);
(%o1)                       F2(a b c)
@end group
@group
(%i2) declare (F2, multiplicative);
(%o2)                         done
@end group
@group
(%i3) F2 (a * b * c);
(%o3)                   F2(a) F2(b) F2(c)
@end group
@end example

@code{declare(nounify(product), multiplicative)} tells Maxima to simplify symbolic products.

@c ===beg===
@c product (a[i] * b[i], i, 1, n);
@c declare (nounify (product), multiplicative);
@c product (a[i] * b[i], i, 1, n);
@c ===end===
@example
@group
(%i1) product (a[i] * b[i], i, 1, n);
                             n
                           /===\
                            ! !
(%o1)                       ! !  a  b
                            ! !   i  i
                           i = 1
@end group
@group
(%i2) declare (nounify (product), multiplicative);
(%o2)                         done
@end group
@group
(%i3) product (a[i] * b[i], i, 1, n);
                          n         n
                        /===\     /===\
                         ! !       ! !
(%o3)                  ( ! !  a )  ! !  b
                         ! !   i   ! !   i
                        i = 1     i = 1
@end group
@end example

@opencatbox
@category{Declarations and inferences} @category{Expressions} @category{Simplification}
@closecatbox
@end defvr

@c NEEDS WORK

@c -----------------------------------------------------------------------------
@anchor{multthru}
@deffn  {関数} multthru @
@fname{multthru} (@var{expr}) @
@fname{multthru} (@var{expr_1}, @var{expr_2})

@var{expr}の（和の）因子に @var{expr}の他の因子を掛けます。
すなわち、@var{expr}は @code{@var{f_1} @var{f_2} ... @var{f_n}}です。
ここで、少なくとも１つの因子―@var{f_i}としましょう―は項の和です。
この和の各項に積の中の他の因子を掛けます。
（すなわち、@var{f_i}を除いた因子すべてです。）
@code{multthru}は指数化された和を展開しません。
この関数は（可換であれ非可換であれ）積を和上に分配する最も速い方法です。
割り算は積として表現されるので、
@code{multthru}は積によって和を割ることにも使うことができます。

@code{multthru (@var{expr_1}, @var{expr_2})}は
（和もしくは等式の） @var{expr_2}の中の各項に @var{expr_1}を掛けます。
もし@var{expr_1}がそれ自身和でないなら、
この形式は @code{multthru (@var{expr_1}*@var{expr_2})}と同値です。

@example
(%i1) x/(x-y)^2 - 1/(x-y) - f(x)/(x-y)^3;
                      1        x         f(x)
(%o1)             - ----- + -------- - --------
                    x - y          2          3
                            (x - y)    (x - y)
(%i2) multthru ((x-y)^3, %);
                           2
(%o2)             - (x - y)  + x (x - y) - f(x)
(%i3) ratexpand (%);
                           2
(%o3)                   - y  + x y - f(x)
(%i4) ((a+b)^10*s^2 + 2*a*b*s + (a*b)^2)/(a*b*s^2);
                        10  2              2  2
                 (b + a)   s  + 2 a b s + a  b
(%o4)            ------------------------------
                                  2
                             a b s
(%i5) multthru (%);  /* note that this does not expand (b+a)^10 */
                                        10
                       2   a b   (b + a)
(%o5)                  - + --- + ---------
                       s    2       a b
                           s
(%i6) multthru (a.(b+c.(d+e)+f));
(%o6)            a . f + a . c . (e + d) + a . b
(%i7) expand (a.(b+c.(d+e)+f));
(%o7)         a . f + a . c . e + a . c . d + a . b
@end example

@opencatbox
@category{Expressions}
@closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@anchor{property_nary}
@defvr {プロパティ} nary

@code{declare(f, nary)}はMaximaに
関数 @code{f}をn項関数として認識するよう命じます。

@code{nary}宣言は
@mxref{function_nary, nary}関数をコールするのと同じではありません。
@code{declare(f, nary)}は唯一の効果は
例えば、 @code{foo(x, foo(y, z))}を
@code{foo(x, y, z)}に整理するように
入れ子の式をフラットにするようMaxima整理器に指示することです。
@mref{declare}も参照してください。

例:

@example
(%i1) H (H (a, b), H (c, H (d, e)));
(%o1)               H(H(a, b), H(c, H(d, e)))
(%i2) declare (H, nary);
(%o2)                         done
(%i3) H (H (a, b), H (c, H (d, e)));
(%o3)                   H(a, b, c, d, e)
@end example
@end defvr

@c NEEDS CLARIFICATION, EXAMPLES

@c -----------------------------------------------------------------------------
@anchor{negdistrib}
@defvr {オプション変数} negdistrib
デフォルト値: @code{true}

@code{negdistrib}が@code{true}の時
 -1が式上に分配されます。
例えば、 @code{-(x + y)}は @code{- y - x}になります。
@code{false}に設定すると @code{- (x + y)}はそのまま表示されることになるでしょう。
これは時々役に立ちますが、よく注意してください;
@code{simp}フラグ同様に、
当然のことながら、Maximaの中でローカルな使用以外には、
これは @code{false}に設定したくないフラグの１つです。

例:

@c ===beg===
@c negdistrib;
@c -(x+y);
@c negdistrib : not negdistrib ;
@c -(x+y);
@c ===end===
@example
@group
(%i1) negdistrib;
(%o1)                         true
@end group
@group
(%i2) -(x+y);
(%o2)                       (- y) - x
@end group
@group
(%i3) negdistrib : not negdistrib ;
(%o3)                         false
@end group
@group
(%i4) -(x+y);
(%o4)                       - (y + x)
@end group
@end example

@opencatbox
@category{Simplification flags and variables}
@closecatbox

@end defvr

@c -----------------------------------------------------------------------------
@anchor{opproperties}
@defvr {システム変数} opproperties

@code{opproperties}は、Maximaの整理器が認識する特殊演算子プロパティのリストです。

項目は関数 @code{define_opproperty}を使って @code{opproperties}リストに追加されます。

例:

@c ===beg===
@c opproperties;
@c ===end===
@example
@group
(%i1) opproperties;
(%o1) [linear, additive, multiplicative, outative, evenfun,
oddfun, commutative, symmetric, antisymmetric, nary,
lassociative, rassociative]
@end group
@end example

@opencatbox
@category{Global variables} @category{Operators} @category{Simplification}
@closecatbox
@end defvr


@c NEEDS EXAMPLES

@c -----------------------------------------------------------------------------
@anchor{define_opproperty}
@deffn {関数} define_opproperty (@var{property_name}, @var{simplifier_fn})

シンボル @var{property_name}が演算子プロパティであることを宣言します。
それは @var{simplifier_fn}で式整理され、
MaximaやLisp関数の名前であったり、ラムダ式であったりします。
@code{define_opproperty}が呼ばれたあと、
関数や演算子は @var{property_name}プロパティを持つと宣言されるかもしれません。
また、それらを式整理するために @var{simplifier_fn}が呼ばれます。

@var{simplifier_fn}は引数1つの関数でなければいけません、
それは、主演算子が @var{property_name}プロパティを持つと宣言された式です。

@var{simplifier_fn}はグローバルフラグ @code{simp}が無効として呼ばれます。
それ故に @var{simplifier_fn}は一般的な式整理器の利用なしに式整理を実行可能でなければいけません。

@code{define_opproperty}は @var{property_name}を
グローバルリスト @code{opproperties}に追加します。

@code{define_opproperty}は @code{done}を返します。

例:

新しいプロパティ @code{identity}を宣言します。
それは @code{simplify_identity}で式整理されます。
@code{f}と @code{g}が新しいプロパティを持つと宣言します。

@c ===beg===
@c define_opproperty (identity, simplify_identity);
@c simplify_identity(e) := first(e);
@c declare ([f, g], identity);
@c f(10 + t);
@c g(3*u) - f(2*u);
@c ===end===
@example
@group
(%i1) define_opproperty (identity, simplify_identity);
(%o1)                         done
@end group
@group
(%i2) simplify_identity(e) := first(e);
(%o2)           simplify_identity(e) := first(e)
@end group
@group
(%i3) declare ([f, g], identity);
(%o3)                         done
@end group
@group
(%i4) f(10 + t);
(%o4)                        t + 10
@end group
@group
(%i5) g(3*u) - f(2*u);
(%o5)                           u
@end group
@end example

@opencatbox
@category{Operators} @category{Simplification}
@closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@anchor{outative}
@defvr {プロパティ} outative

@code{declare (f, outative)}は Maximaの整理器に
@code{f}の引数の中の定数因子が外に出すことができることを告げます。

@enumerate
@item
もし@code{f}が1変数関数なら、
整理器が積に適用された @code{f}に出会うといつでも、
その積は定数因子と定数でない因子に分割され、定数因子が外に出されます。
例えば、 @code{a}を定数とすると、  @code{f(a*x)}は @code{a*f(x)}に整理されます。
アトムでない定数因子は外に出ません。
@item
もし@code{f}が多変数関数なら、
outativityは @code{sum}や @code{integrate}の場合のように定義されます。
すなわち、 @code{a}が@code{x}に依らないとすると、
@code{f (a*g(x), x)}は @code{a * f(g(x), x)}に整理されます。
@end enumerate

@code{sum}, @code{integrate}, @code{limit}はすべて @code{outative}です。

例:

@c ===beg===
@c F1 (100 * x);
@c declare (F1, outative);
@c F1 (100 * x);
@c declare (zz, constant);
@c F1 (zz * y);
@c ===end===
@example
@group
(%i1) F1 (100 * x);
(%o1)                       F1(100 x)
@end group
@group
(%i2) declare (F1, outative);
(%o2)                         done
@end group
@group
(%i3) F1 (100 * x);
(%o3)                       100 F1(x)
@end group
@group
(%i4) declare (zz, constant);
(%o4)                         done
@end group
@group
(%i5) F1 (zz * y);
(%o5)                       zz F1(y)
@end group
@end example

@opencatbox
@category{Declarations and inferences} @category{Operators}
@closecatbox
@end defvr

@c -----------------------------------------------------------------------------
@anchor{radcan}
@deffn {関数} radcan (@var{expr})

対数関数、指数関数、累乗根を含む @var{expr}を
与えられ場変数の順序で式の大きなクラス上の標準形式に整理します;
関数的に同値な形式は特殊な形式にマップされます。
式の幾分大きなクラスに対して @code{radcan}は正規形を生成します。
このクラスの同値な2式は必ずしも見た目が同じわけではありませんが、
それらの差は @code{radcan}によって0に整理されます。

いくつかの式では @code{radcan}は特殊な時間消費をします。
これは因数分解や指数関数の部分分解展開に基づいた整理のための式のコンポーネントの間のある関係を探求するコストです。

@c %e_to_numlog NEEDS ITS OWN @defvar !!!

@c %e_to_numlog HAS NO EFFECT ON RADCAN. RADCAN ALWAYS SIMPLIFIES
@c exp(a*log(x)) --> x^a. Commenting the following out. 11/2009
@c When @code{%e_to_numlog} is @code{true}, @code{%e^(r*log(expr))} simplifies
@c to @code{expr^r} if @code{r} is a rational number.

@c RADEXPAND CONTROLS THE SIMPLIFICATION OF THE POWER FUNCTION, E.G.
@c (x*y)^a --> x^a*y^a AND (x^a)^b --> x^(a*b), IF RADEXPAND HAS THE VALUE 'ALL.
@c THE VALUE OF RADEXPAND HAS NO EFFECT ON RADCAN. RADCAN ALWAYS SIMPLIFIES
@c THE ABOVE EXPRESSIONS. COMMENTING THE FOLLOWING OUT. 11/2009
@c When @code{radexpand} is @code{false}, certain transformations are inhibited.
@c @code{radcan (sqrt (1-x))} remains @code{sqrt (1-x)} and is not simplified
@c to @code{%i sqrt (x-1)}. @code{radcan (sqrt (x^2 - 2*x + 1))} remains
@c @code{sqrt (x^2 - 2*x + 1)} and is not simplified to @code{x - 1}.

例:

@c ===beg===
@c radcan((log(x+x^2)-log(x))^a/log(1+x)^(a/2));
@c radcan((log(1+2*a^x+a^(2*x))/log(1+a^x)));
@c radcan((%e^x-1)/(1+%e^(x/2)));
@c ===end===
@example
@group
(%i1) radcan((log(x+x^2)-log(x))^a/log(1+x)^(a/2));
                                    a/2
(%o1)                     log(x + 1)
@end group
@group
(%i2) radcan((log(1+2*a^x+a^(2*x))/log(1+a^x)));
(%o2)                           2
@end group
@group
(%i3) radcan((%e^x-1)/(1+%e^(x/2)));
                              x/2
(%o3)                       %e    - 1
@end group
@end example

@opencatbox
@category{Simplification functions}
@closecatbox
@end deffn

@c NEEDS CLARIFICATION, EXAMPLES

@c -----------------------------------------------------------------------------
@anchor{radexpand}
@defvr {オプション変数} radexpand
デフォルト値: @code{true}

@code{radexpand}は根号のいくつかの整理を制御します。

@code{radexpand}が @code{all}の時
n乗の積の因子のn番目の根を根号の外に出すようにします。
例えば、もし@code{radexpand}が @code{all}なら、
@code{sqrt (16*x^2)}は @code{4*x}に整理されます。

@c EXPRESS SIMPLIFICATON RULES IN GENERAL CASE, NOT SPECIAL CASE
特に @code{sqrt (x^2)}を考えます。
@itemize @bullet
@item
もし @code{radexpand}が @code{all}か @code{assume (x > 0)}が実行されたなら、
@code{sqrt(x^2)}は @code{x}に整理されます。
@item
もし @code{radexpand}が @code{true}かつ
@code{domain}が @code{real}(これはデフォルトです)なら、
@code{sqrt(x^2)}は @code{abs(x)}に整理されます。
@item
もし @code{radexpand}が @code{false}か、
@code{radexpand}が @code{true}かつ @code{domain}が @code{complex}なら、
@code{sqrt(x^2)}は整理されません。
@end itemize

@c CORRECT STATEMENT HERE ???
@code{domain}は @code{radexpand}が @code{true}の時だけ
意味を持つことに注意してください。

@opencatbox
@category{Simplification flags and variables}
@closecatbox

@end defvr


@c NEEDS CLARIFICATION, EXAMPLES

@c -----------------------------------------------------------------------------
@anchor{rassociative}
@defvr {プロパティ} rassociative

@code{declare (g, rassociative)}は
Maximaの整理器に
@code{g}が右結合であることを知らせます。
例えば、
@code{g(g(a, b), g(c, d))}は @code{g(a, g(b, g(c, d)))}に整理されます。

@opencatbox
@category{Declarations and inferences} @category{Operators}
@closecatbox
@end defvr

@c NEEDS CLARIFICATION, EXAMPLES

@c -----------------------------------------------------------------------------
@anchor{scsimp}
@deffn {関数} scsimp (@var{expr}, @var{rule_1}, ..., @var{rule_n})

順次比較整理 (Stouteによる方法)。
@code{scsimp}は、
規則 @var{rule_1}, ..., @var{rule_n}に従って、
@var{expr}を整理しようとします。
もしより小さな式が得られたら、
プロセスは繰り返されます。
そうでなければ、すべての整理が試された後、
元の答えを返します。

@c MERGE EXAMPLES INTO THIS FILE
@code{example (scsimp)}はいくつかの例を表示します。

@opencatbox
@category{Simplification functions}
@closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@anchor{simp}
@defvr {オプション変数} simp
デフォルト値: @code{true}

@code{simp}は整理を有効にします。
これはデフォルトです。
@code{simp}は @code{evflag}でもあります。
それは関数 @code{ev}に認識されます。
@mref{ev}を参照してください。

@code{simp}が値 @code{false}で @code{evflag}として使われる時、
式の評価フェイズの間だけ整理は抑制されます。
フラグは評価フェイズに続く整理を抑制しません。

多くの Maxima関数や演算子は
正常に機能することを可能にするために整理を要求します。
整理が無効になっている時、多くの結果は不備があり、
加えて、不正確な結果であったりプログラムエラーになったりします。

例:

グローバルに整理をスイッチオフします。
式 @code{sin(1.0)}は数値に整理されません。
@code{simp}-フラグは整理をオンにスイッチします。

@c ===beg===
@c simp:false;
@c sin(1.0);
@c sin(1.0),simp;
@c ===end===
@example
@group
(%i1) simp:false;
(%o1)                         false
@end group
@group
(%i2) sin(1.0);
(%o2)                       sin(1.0)
@end group
@group
(%i3) sin(1.0),simp;
(%o3)                  0.8414709848078965
@end group
@end example

整理を再びスイッチオンします。
@code{simp}-フラグは完全には整理を抑制できません。
割り当ては式の評価フェイズの間に起こるので、
出力は整理された式を示しますが、変数 @code{x}は値として未整理の式を持ちます。

@c ===beg===
@c simp:true;
@c x:sin(1.0),simp:false;
@c :lisp $x
@c ===end===
@example
@group
(%i1) simp:true;
(%o1)                         true
@end group
@group
(%i2) x:sin(1.0),simp:false;
(%o2)                  0.8414709848078965
@end group
@group
(%i3) :lisp $x
((%SIN) 1.0)
@end group
@end example

@opencatbox
@category{Evaluation flags}
@closecatbox
@end defvr

@c NEEDS CLARIFICATION, EXAMPLES

@c -----------------------------------------------------------------------------
@anchor{symmetric}
@defvr {プロパティ} symmetric

@code{declare (h, symmetric)}は Maximaの整理器に
@code{h}が対称関数であることを知らせます。
例えば、@code{h (x, z, y)}は @code{h (x, y, z)}に整理されます。

@code{commutative}は @code{symmetric}と同義です。

@opencatbox
@category{Declarations and inferences} @category{Operators}
@closecatbox
@end defvr

@c -----------------------------------------------------------------------------
@anchor{xthru}
@deffn {関数} xthru (@var{expr})

（和の） @var{expr}のすべての項を
共通分母上で @code{ratsimp}がするように積や指数和を展開することなしに結合させます。
因子が陽であるときだけ、
@code{xthru}は有理式の分子と分母の共通因子を消去します。

@c REPHRASE IN NEUTRAL TONE (GET RID OF "IT IS BETTER")
分子と分母の最大公約数の陽因子を消去するために、式を @code{ratsimp}する前に
@code{xthru}を使うのがよい場合があります。

@c ===beg===
@c ((x+2)^20 - 2*y)/(x+y)^20 + (x+y)^(-19) - x/(x+y)^20;
@c xthru (%);
@c ===end===
@example
@group
(%i1) ((x+2)^20 - 2*y)/(x+y)^20 + (x+y)^(-19) - x/(x+y)^20;
                                20
                 1       (x + 2)   - 2 y       x
(%o1)        --------- + --------------- - ---------
                    19             20             20
             (y + x)        (y + x)        (y + x)
@end group
@group
(%i2) xthru (%);
                                 20
                          (x + 2)   - y
(%o2)                     -------------
                                   20
                            (y + x)
@end group
@end example

@opencatbox
@category{Expressions}
@closecatbox
@end deffn
